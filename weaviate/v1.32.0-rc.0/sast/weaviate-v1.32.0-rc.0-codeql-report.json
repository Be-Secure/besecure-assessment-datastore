[
  {
    "number": 140,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/140",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/140",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/incorrect-integer-conversion",
      "severity": "warning",
      "description": "Incorrect conversion between integer types",
      "name": "go/incorrect-integer-conversion",
      "tags": ["external/cwe/cwe-190","external/cwe/cwe-681","security"],
      "full_description": "Converting the result of `strconv.Atoi`, `strconv.ParseInt`, and `strconv.ParseUint` to integer types of smaller bit size can produce unexpected values.",
      "help": "# Incorrect conversion between integer types\nIf a string is parsed into an int using `strconv.Atoi`, and subsequently that int is converted into another integer type of a smaller size, the result can produce unexpected values.\n\nThis also applies to the results of `strconv.ParseInt` and `strconv.ParseUint` when the specified size is larger than the size of the type that number is converted to.\n\n\n## Recommendation\nIf you need to parse integer values with specific bit sizes, avoid `strconv.Atoi`, and instead use `strconv.ParseInt` or `strconv.ParseUint`, which also allow specifying the bit size.\n\nWhen using those functions, be careful to not convert the result to another type with a smaller bit size than the bit size you specified when parsing the number.\n\nIf this is not possible, then add upper (and lower) bound checks specific to each type and bit size (you can find the minimum and maximum value for each type in the `math` package).\n\nNote that CodeQL is only able to identify bounds checks that compare against a constant value. When a variable is used in the comparison, CodeQL is unable to determine the value of the variable at runtime and will not recognize the bounds check.\n\n\n## Example\nIn the first example, assume that an input string is passed to `parseAllocateBad1` function, parsed by `strconv.Atoi`, and then converted into an `int32` type:\n\n\n```go\npackage main\n\nimport (\n\t\"strconv\"\n)\n\nfunc parseAllocateBad1(wanted string) int32 {\n\tparsed, err := strconv.Atoi(wanted)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateBad2(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\n\n```\nThe bounds are not checked, so this means that if the provided number is greater than the maximum value of type `int32`, the resulting value from the conversion will be different from the actual provided value.\n\nTo avoid unexpected values, you should either use the other functions provided by the `strconv` package to parse the specific types and bit sizes as shown in the `parseAllocateGood2` function; or check bounds as in the `parseAllocateGood1` function.\n\n\n```go\npackage main\n\nimport (\n\t\"math\"\n\t\"strconv\"\n)\n\nfunc main() {\n\n}\n\nconst DefaultAllocate int32 = 256\n\nfunc parseAllocateGood1(desired string) int32 {\n\tparsed, err := strconv.Atoi(desired)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\t// GOOD: check for lower and upper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\nfunc parseAllocateGood2(desired string) int32 {\n\t// GOOD: parse specifying the bit size\n\tparsed, err := strconv.ParseInt(desired, 10, 32)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\treturn int32(parsed)\n}\n\nfunc parseAllocateGood3(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 32)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateGood4(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// GOOD: check for lower and uppper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\n\n```\n\n## Example\nIn the second example, assume that an input string is passed to `parseAllocateBad2` function, parsed by `strconv.ParseInt` with a bit size set to 64, and then converted into an `int32` type:\n\n\n```go\npackage main\n\nimport (\n\t\"strconv\"\n)\n\nfunc parseAllocateBad1(wanted string) int32 {\n\tparsed, err := strconv.Atoi(wanted)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateBad2(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\n\n```\nIf the provided number is greater than the maximum value of type `int32`, the resulting value from the conversion will be different from the actual provided value.\n\nTo avoid unexpected values, you should specify the correct bit size as in `parseAllocateGood3`; or check bounds before making the conversion as in `parseAllocateGood4`.\n\n\n```go\npackage main\n\nimport (\n\t\"math\"\n\t\"strconv\"\n)\n\nfunc main() {\n\n}\n\nconst DefaultAllocate int32 = 256\n\nfunc parseAllocateGood1(desired string) int32 {\n\tparsed, err := strconv.Atoi(desired)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\t// GOOD: check for lower and upper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\nfunc parseAllocateGood2(desired string) int32 {\n\t// GOOD: parse specifying the bit size\n\tparsed, err := strconv.ParseInt(desired, 10, 32)\n\tif err != nil {\n\t\treturn DefaultAllocate\n\t}\n\treturn int32(parsed)\n}\n\nfunc parseAllocateGood3(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 32)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn int32(parsed)\n}\nfunc parseAllocateGood4(wanted string) int32 {\n\tparsed, err := strconv.ParseInt(wanted, 10, 64)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\t// GOOD: check for lower and uppper bounds\n\tif parsed > 0 && parsed <= math.MaxInt32 {\n\t\treturn int32(parsed)\n\t}\n\treturn DefaultAllocate\n}\n\n```\n\n## References\n* Wikipedia [Integer overflow](https://en.wikipedia.org/wiki/Integer_overflow).\n* Go language specification [Integer overflow](https://golang.org/ref/spec#Integer_overflow).\n* Documentation for [strconv.Atoi](https://golang.org/pkg/strconv/#Atoi).\n* Documentation for [strconv.ParseInt](https://golang.org/pkg/strconv/#ParseInt).\n* Documentation for [strconv.ParseUint](https://golang.org/pkg/strconv/#ParseUint).\n* Common Weakness Enumeration: [CWE-190](https://cwe.mitre.org/data/definitions/190.html).\n* Common Weakness Enumeration: [CWE-681](https://cwe.mitre.org/data/definitions/681.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "Incorrect conversion of a signed 64-bit integer from strconv.ParseInt to a lower bit size type int without an upper bound check."
      },
      "location": {
        "path": "usecases/config/environment.go",
        "start_line": 665,
        "end_line": 665,
        "start_column": 41,
        "end_column": 51
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/140/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 139,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/139",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/139",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/uncontrolled-allocation-size",
      "severity": "error",
      "description": "Slice memory allocation with excessive size value",
      "name": "go/uncontrolled-allocation-size",
      "tags": ["external/cwe/cwe-770","security"],
      "full_description": "Allocating memory for slices with the built-in make function from user-controlled sources can lead to a denial of service.",
      "help": "# Slice memory allocation with excessive size value\nUsing untrusted input to allocate slices with the built-in `make` function could lead to excessive memory allocation and potentially cause the program to crash due to running out of memory. This vulnerability could be exploited to perform a denial-of-service attack by consuming all available server resources.\n\n\n## Recommendation\nImplement a maximum allowed value for size allocations with the built-in `make` function to prevent excessively large allocations.\n\n\n## Example\nIn the following example snippet, the `n` parameter is user-controlled.\n\nIf the external user provides an excessively large value, the application allocates a slice of size `n` without further verification, potentially exhausting all the available memory.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryBad(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\nOne way to prevent this vulnerability is by implementing a maximum allowed value for the user-controlled input, as seen in the following example:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryGood(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\tMaxValue := 6\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif collectionSize < 0 || collectionSize > MaxValue {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This memory allocation depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/sorter/inverted_sorter.go",
        "start_line": 280,
        "end_line": 280,
        "start_column": 40,
        "end_column": 45
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/139/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 138,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/138",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/138",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/uncontrolled-allocation-size",
      "severity": "error",
      "description": "Slice memory allocation with excessive size value",
      "name": "go/uncontrolled-allocation-size",
      "tags": ["external/cwe/cwe-770","security"],
      "full_description": "Allocating memory for slices with the built-in make function from user-controlled sources can lead to a denial of service.",
      "help": "# Slice memory allocation with excessive size value\nUsing untrusted input to allocate slices with the built-in `make` function could lead to excessive memory allocation and potentially cause the program to crash due to running out of memory. This vulnerability could be exploited to perform a denial-of-service attack by consuming all available server resources.\n\n\n## Recommendation\nImplement a maximum allowed value for size allocations with the built-in `make` function to prevent excessively large allocations.\n\n\n## Example\nIn the following example snippet, the `n` parameter is user-controlled.\n\nIf the external user provides an excessively large value, the application allocates a slice of size `n` without further verification, potentially exhausting all the available memory.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryBad(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\nOne way to prevent this vulnerability is by implementing a maximum allowed value for the user-controlled input, as seen in the following example:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryGood(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\tMaxValue := 6\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif collectionSize < 0 || collectionSize > MaxValue {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This memory allocation depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/sorter/inverted_sorter.go",
        "start_line": 217,
        "end_line": 217,
        "start_column": 32,
        "end_column": 37
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/138/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 137,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/137",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/137",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/uncontrolled-allocation-size",
      "severity": "error",
      "description": "Slice memory allocation with excessive size value",
      "name": "go/uncontrolled-allocation-size",
      "tags": ["external/cwe/cwe-770","security"],
      "full_description": "Allocating memory for slices with the built-in make function from user-controlled sources can lead to a denial of service.",
      "help": "# Slice memory allocation with excessive size value\nUsing untrusted input to allocate slices with the built-in `make` function could lead to excessive memory allocation and potentially cause the program to crash due to running out of memory. This vulnerability could be exploited to perform a denial-of-service attack by consuming all available server resources.\n\n\n## Recommendation\nImplement a maximum allowed value for size allocations with the built-in `make` function to prevent excessively large allocations.\n\n\n## Example\nIn the following example snippet, the `n` parameter is user-controlled.\n\nIf the external user provides an excessively large value, the application allocates a slice of size `n` without further verification, potentially exhausting all the available memory.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryBad(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\nOne way to prevent this vulnerability is by implementing a maximum allowed value for the user-controlled input, as seen in the following example:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryGood(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\tMaxValue := 6\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif collectionSize < 0 || collectionSize > MaxValue {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This memory allocation depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/sorter/inverted_sorter.go",
        "start_line": 158,
        "end_line": 158,
        "start_column": 32,
        "end_column": 37
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/137/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 136,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/136",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/136",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/uncontrolled-allocation-size",
      "severity": "error",
      "description": "Slice memory allocation with excessive size value",
      "name": "go/uncontrolled-allocation-size",
      "tags": ["external/cwe/cwe-770","security"],
      "full_description": "Allocating memory for slices with the built-in make function from user-controlled sources can lead to a denial of service.",
      "help": "# Slice memory allocation with excessive size value\nUsing untrusted input to allocate slices with the built-in `make` function could lead to excessive memory allocation and potentially cause the program to crash due to running out of memory. This vulnerability could be exploited to perform a denial-of-service attack by consuming all available server resources.\n\n\n## Recommendation\nImplement a maximum allowed value for size allocations with the built-in `make` function to prevent excessively large allocations.\n\n\n## Example\nIn the following example snippet, the `n` parameter is user-controlled.\n\nIf the external user provides an excessively large value, the application allocates a slice of size `n` without further verification, potentially exhausting all the available memory.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryBad(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\nOne way to prevent this vulnerability is by implementing a maximum allowed value for the user-controlled input, as seen in the following example:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryGood(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\tMaxValue := 6\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif collectionSize < 0 || collectionSize > MaxValue {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This memory allocation depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/shard_read.go",
        "start_line": 639,
        "end_line": 639,
        "start_column": 33,
        "end_column": 40
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/136/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 135,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/135",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/135",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/uncontrolled-allocation-size",
      "severity": "error",
      "description": "Slice memory allocation with excessive size value",
      "name": "go/uncontrolled-allocation-size",
      "tags": ["external/cwe/cwe-770","security"],
      "full_description": "Allocating memory for slices with the built-in make function from user-controlled sources can lead to a denial of service.",
      "help": "# Slice memory allocation with excessive size value\nUsing untrusted input to allocate slices with the built-in `make` function could lead to excessive memory allocation and potentially cause the program to crash due to running out of memory. This vulnerability could be exploited to perform a denial-of-service attack by consuming all available server resources.\n\n\n## Recommendation\nImplement a maximum allowed value for size allocations with the built-in `make` function to prevent excessively large allocations.\n\n\n## Example\nIn the following example snippet, the `n` parameter is user-controlled.\n\nIf the external user provides an excessively large value, the application allocates a slice of size `n` without further verification, potentially exhausting all the available memory.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryBad(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\nOne way to prevent this vulnerability is by implementing a maximum allowed value for the user-controlled input, as seen in the following example:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryGood(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\tMaxValue := 6\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif collectionSize < 0 || collectionSize > MaxValue {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This memory allocation depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/priorityqueue/queue.go",
        "start_line": 115,
        "end_line": 115,
        "start_column": 31,
        "end_column": 39
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/135/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 134,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/134",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/134",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/uncontrolled-allocation-size",
      "severity": "error",
      "description": "Slice memory allocation with excessive size value",
      "name": "go/uncontrolled-allocation-size",
      "tags": ["external/cwe/cwe-770","security"],
      "full_description": "Allocating memory for slices with the built-in make function from user-controlled sources can lead to a denial of service.",
      "help": "# Slice memory allocation with excessive size value\nUsing untrusted input to allocate slices with the built-in `make` function could lead to excessive memory allocation and potentially cause the program to crash due to running out of memory. This vulnerability could be exploited to perform a denial-of-service attack by consuming all available server resources.\n\n\n## Recommendation\nImplement a maximum allowed value for size allocations with the built-in `make` function to prevent excessively large allocations.\n\n\n## Example\nIn the following example snippet, the `n` parameter is user-controlled.\n\nIf the external user provides an excessively large value, the application allocates a slice of size `n` without further verification, potentially exhausting all the available memory.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryBad(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\nOne way to prevent this vulnerability is by implementing a maximum allowed value for the user-controlled input, as seen in the following example:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryGood(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\tMaxValue := 6\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif collectionSize < 0 || collectionSize > MaxValue {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This memory allocation depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/priorityqueue/queue.go",
        "start_line": 61,
        "end_line": 61,
        "start_column": 29,
        "end_column": 37
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/134/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 133,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/133",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/133",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/uncontrolled-allocation-size",
      "severity": "error",
      "description": "Slice memory allocation with excessive size value",
      "name": "go/uncontrolled-allocation-size",
      "tags": ["external/cwe/cwe-770","security"],
      "full_description": "Allocating memory for slices with the built-in make function from user-controlled sources can lead to a denial of service.",
      "help": "# Slice memory allocation with excessive size value\nUsing untrusted input to allocate slices with the built-in `make` function could lead to excessive memory allocation and potentially cause the program to crash due to running out of memory. This vulnerability could be exploited to perform a denial-of-service attack by consuming all available server resources.\n\n\n## Recommendation\nImplement a maximum allowed value for size allocations with the built-in `make` function to prevent excessively large allocations.\n\n\n## Example\nIn the following example snippet, the `n` parameter is user-controlled.\n\nIf the external user provides an excessively large value, the application allocates a slice of size `n` without further verification, potentially exhausting all the available memory.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryBad(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\nOne way to prevent this vulnerability is by implementing a maximum allowed value for the user-controlled input, as seen in the following example:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryGood(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\tMaxValue := 6\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif collectionSize < 0 || collectionSize > MaxValue {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This memory allocation depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/priorityqueue/queue.go",
        "start_line": 48,
        "end_line": 48,
        "start_column": 29,
        "end_column": 37
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/133/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 132,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/132",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/132",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/uncontrolled-allocation-size",
      "severity": "error",
      "description": "Slice memory allocation with excessive size value",
      "name": "go/uncontrolled-allocation-size",
      "tags": ["external/cwe/cwe-770","security"],
      "full_description": "Allocating memory for slices with the built-in make function from user-controlled sources can lead to a denial of service.",
      "help": "# Slice memory allocation with excessive size value\nUsing untrusted input to allocate slices with the built-in `make` function could lead to excessive memory allocation and potentially cause the program to crash due to running out of memory. This vulnerability could be exploited to perform a denial-of-service attack by consuming all available server resources.\n\n\n## Recommendation\nImplement a maximum allowed value for size allocations with the built-in `make` function to prevent excessively large allocations.\n\n\n## Example\nIn the following example snippet, the `n` parameter is user-controlled.\n\nIf the external user provides an excessively large value, the application allocates a slice of size `n` without further verification, potentially exhausting all the available memory.\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryBad(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\nOne way to prevent this vulnerability is by implementing a maximum allowed value for the user-controlled input, as seen in the following example:\n\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nfunc OutOfMemoryGood(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\tMaxValue := 6\n\tqueryStr := query.Get(\"n\")\n\tcollectionSize, err := strconv.Atoi(queryStr)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif collectionSize < 0 || collectionSize > MaxValue {\n\t\thttp.Error(w, \"Bad request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tresult := make([]string, collectionSize)\n\tfor i := 0; i < collectionSize; i++ {\n\t\tresult[i] = fmt.Sprintf(\"Item %d\", i+1)\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(result)\n}\n\n```\n\n## References\n* OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html)\n* Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This memory allocation depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/priorityqueue/queue.go",
        "start_line": 35,
        "end_line": 35,
        "start_column": 29,
        "end_column": 37
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/132/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 131,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/131",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/131",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/disabled-certificate-check",
      "severity": "warning",
      "description": "Disabled TLS certificate check",
      "name": "go/disabled-certificate-check",
      "tags": ["external/cwe/cwe-295","security"],
      "full_description": "If an application disables TLS certificate checking, it may be vulnerable to man-in-the-middle attacks.",
      "help": "# Disabled TLS certificate check\nThe field `InsecureSkipVerify` controls whether a TLS client verifies the server's certificate chain and host name. If set to `true`, the client will accept any certificate and any host name in that certificate, making it susceptible to man-in-the-middle attacks.\n\n\n## Recommendation\nDo not set `InsecureSkipVerify` to `true` except in tests.\n\n\n## Example\nThe following code snippet shows a function that performs an HTTP request over TLS with certificate verification disabled:\n\n\n```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"net/http\"\n)\n\nfunc doAuthReq(authReq *http.Request) *http.Response {\n\ttr := &http.Transport{\n\t\tTLSClientConfig: &tls.Config{InsecureSkipVerify: true},\n\t}\n\tclient := &http.Client{Transport: tr}\n\tres, _ := client.Do(authReq)\n\treturn res\n}\n\n```\nWhile this is acceptable in a test, it should not be used in production code. Instead, certificates should be configured such that verification can be performed.\n\n\n## References\n* Package tls: [Config](https://golang.org/pkg/crypto/tls/#Config).\n* SSL.com: [Browsers and Certificate Validation](https://www.ssl.com/article/browsers-and-certificate-validation/).\n* Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "InsecureSkipVerify should not be used in production code."
      },
      "location": {
        "path": "test/helper/grpc_client.go",
        "start_line": 29,
        "end_line": 29,
        "start_column": 4,
        "end_column": 28
      },
      "classifications": ["test"]
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/131/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 130,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/130",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/130",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value."
      },
      "location": {
        "path": "usecases/integrity/file_crc32.go",
        "start_line": 21,
        "end_line": 21,
        "start_column": 23,
        "end_column": 27
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/130/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 129,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/129",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/129",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value."
      },
      "location": {
        "path": "usecases/file/file_metadata.go",
        "start_line": 28,
        "end_line": 28,
        "start_column": 21,
        "end_column": 29
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/129/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 128,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/128",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/128",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value."
      },
      "location": {
        "path": "modules/backup-filesystem/backup.go",
        "start_line": 202,
        "end_line": 202,
        "start_column": 20,
        "end_column": 30
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/128/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 127,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/127",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/127",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value."
      },
      "location": {
        "path": "modules/backup-filesystem/backup.go",
        "start_line": 169,
        "end_line": 169,
        "start_column": 24,
        "end_column": 34
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/127/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 126,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/126",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/126",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value."
      },
      "location": {
        "path": "modules/backup-filesystem/backup.go",
        "start_line": 166,
        "end_line": 166,
        "start_column": 24,
        "end_column": 27
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/126/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 125,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/125",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/125",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value."
      },
      "location": {
        "path": "modules/backup-filesystem/backup.go",
        "start_line": 116,
        "end_line": 116,
        "start_column": 25,
        "end_column": 35
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/125/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 124,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/124",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/124",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value."
      },
      "location": {
        "path": "modules/backup-filesystem/backup.go",
        "start_line": 112,
        "end_line": 112,
        "start_column": 24,
        "end_column": 27
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/124/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 123,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/123",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/123",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value."
      },
      "location": {
        "path": "modules/backup-filesystem/backup.go",
        "start_line": 70,
        "end_line": 70,
        "start_column": 25,
        "end_column": 35
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/123/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 122,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/122",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/122",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "modules/backup-filesystem/backup.go",
        "start_line": 60,
        "end_line": 60,
        "start_column": 23,
        "end_column": 31
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/122/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 121,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/121",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/121",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "modules/backup-filesystem/backup.go",
        "start_line": 40,
        "end_line": 40,
        "start_column": 31,
        "end_column": 39
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/121/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 120,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/120",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/120",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "entities/diskio/files.go",
        "start_line": 47,
        "end_line": 47,
        "start_column": 20,
        "end_column": 24
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/120/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 119,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/119",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/119",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/vector/hnsw/corrupt_commit_logs_fixer.go",
        "start_line": 59,
        "end_line": 59,
        "start_column": 23,
        "end_column": 31
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/119/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 118,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/118",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/118",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/vector/hnsw/commit_logger_snapshot.go",
        "start_line": 496,
        "end_line": 496,
        "start_column": 28,
        "end_column": 36
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/118/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 117,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/117",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/117",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/vector/hnsw/commit_logger_snapshot.go",
        "start_line": 459,
        "end_line": 459,
        "start_column": 23,
        "end_column": 31
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/117/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 116,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/116",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/116",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/vector/hnsw/commit_logger_snapshot.go",
        "start_line": 344,
        "end_line": 344,
        "start_column": 29,
        "end_column": 40
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/116/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 115,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/115",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/115",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/vector/hnsw/commit_logger_snapshot.go",
        "start_line": 267,
        "end_line": 267,
        "start_column": 25,
        "end_column": 60
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/115/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 114,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/114",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/114",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/vector/hnsw/commit_logger.go",
        "start_line": 317,
        "end_line": 317,
        "start_column": 24,
        "end_column": 59
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/114/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 113,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/113",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/113",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/vector/hnsw/commit_logger.go",
        "start_line": 233,
        "end_line": 233,
        "start_column": 27,
        "end_column": 34
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/113/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 112,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/112",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/112",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/vector/hnsw/commit_logger.go",
        "start_line": 180,
        "end_line": 180,
        "start_column": 27,
        "end_column": 30
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/112/instances",
    "dismissal_approved_by": null
  },
  {
    "number": 111,
    "created_at": "2025-07-11T12:38:46Z",
    "updated_at": "2025-07-11T12:38:46Z",
    "url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/111",
    "html_url": "https://github.com/Be-Secure/weaviate/security/code-scanning/111",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "go/path-injection",
      "severity": "error",
      "description": "Uncontrolled data used in path expression",
      "name": "go/path-injection",
      "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
      "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
      "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first example, a file name is read from an HTTP request and then used to access a file. However, a malicious user could enter a file name which is an absolute path, such as \"/etc/passwd\".\n\nIn the second example, it appears that the user is restricted to opening a file within the `\"user\"` home directory. However, a malicious user could enter a file name containing special characters. For example, the string `\"../../etc/passwd\"` will result in the code reading the file located at \"/home/user/../../etc/passwd\", which is the system's password file. This file would then be sent back to the user, giving them access to password information.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// BAD: This could read any file on the file system\n\tdata, _ := ioutil.ReadFile(path)\n\tw.Write(data)\n\n\t// BAD: This could still read any file on the file system\n\tdata, _ = ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\t// (Note that this is only suitable if `path` is expected to have a single component!)\n\tif strings.Contains(path, \"/\") || strings.Contains(path, \"\\\\\") || strings.Contains(path, \"..\") {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(filepath.Join(\"/home/user/\", path))\n\tw.Write(data)\n}\n\n```\nNote that this approach is only suitable if the input is expected to be a single file name.\n\nIf the input can be a path with multiple components, you can make it safe by verifying that the path is within a specific directory that is considered safe. You can do this by resolving the input with respect to that directory, and then checking that the resulting path is still within it.\n\n\n```go\npackage main\n\nimport (\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nconst safeDir = \"/home/user/\"\n\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tpath := r.URL.Query()[\"path\"][0]\n\n\t// GOOD: ensure that the resolved path is within the safe directory\n\tabsPath, err := filepath.Abs(filepath.Join(safeDir, path))\n\tif err != nil || !strings.HasPrefix(absPath, safeDir) {\n\t\thttp.Error(w, \"Invalid file name\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdata, _ := ioutil.ReadFile(absPath)\n\tw.Write(data)\n}\n\n```\nNote that `/home/user` is just an example, you should replace it with the actual safe directory in your application. Also, while in this example the path of the safe directory is absolute, this may not always be the case, and you may need to resolve it first before checking the input.\n\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.22.1"
    },
    "most_recent_instance": {
      "ref": "refs/heads/release-v1.32.0-rc.0",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"autobuild\",\"language\":\"go\"}",
      "category": "/language:go",
      "state": "open",
      "commit_sha": "07496d78266d8ef302c6f2bb1b73c5ae766834a8",
      "message": {
        "text": "This path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value.\nThis path depends on a user-provided value."
      },
      "location": {
        "path": "adapters/repos/db/vector/hnsw/commit_logger.go",
        "start_line": 175,
        "end_line": 175,
        "start_column": 21,
        "end_column": 24
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/weaviate/code-scanning/alerts/111/instances",
    "dismissal_approved_by": null
  }
]