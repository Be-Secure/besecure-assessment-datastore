[
  {
    "number": 80,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/80",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/80",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/clear-text-logging-sensitive-data",
      "severity": "error",
      "description": "Clear-text logging of sensitive information",
      "name": "py/clear-text-logging-sensitive-data",
      "tags": ["external/cwe/cwe-312","external/cwe/cwe-359","external/cwe/cwe-532","security"],
      "full_description": "Logging sensitive information without encryption or hashing can expose it to an attacker.",
      "help": "# Clear-text logging of sensitive information\nIf sensitive data is written to a log entry it could be exposed to an attacker who gains access to the logs.\n\nPotential attackers can obtain sensitive user data when the log output is displayed. Additionally that data may expose system information such as full path names, system information, and sometimes usernames and passwords.\n\n\n## Recommendation\nSensitive data should not be logged.\n\n\n## Example\nIn the example the entire process environment is logged using \\`print\\`. Regular users of the production deployed application should not have access to this much information about the environment configuration.\n\n\n```python\n# BAD: Logging cleartext sensitive data\nimport os\nprint(f\"[INFO] Environment: {os.environ}\")\n```\nIn the second example the data that is logged is not sensitive.\n\n\n```python\nnot_sensitive_data = {'a': 1, 'b': 2}\n# GOOD: it is fine to log data that is not sensitive\nprint(f\"[INFO] Some object contains: {not_sensitive_data}\")\n```\n\n## References\n* OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n* Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "This expression logs sensitive data (password) as clear text."
      },
      "location": {
        "path": "examples/hardcoded-passwords.py",
        "start_line": 34,
        "end_line": 34,
        "start_column": 15,
        "end_column": 27
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/80/instances"
  },
  {
    "number": 79,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/79",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/79",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-cryptographic-algorithm",
      "severity": "warning",
      "description": "Use of a broken or weak cryptographic algorithm",
      "name": "py/weak-cryptographic-algorithm",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Using broken or weak cryptographic algorithms can compromise security.",
      "help": "# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\nThis query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.\n\n\n## Example\nThe following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.\n\n\n```python\nfrom Crypto.Cipher import DES, AES\n\ncipher = DES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # BAD: weak encryption\n\n\ncipher = AES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # GOOD: strong encryption\n\n\n```\nNOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).\n\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "The cryptographic algorithm ARC4 is broken or weak, and should not be used."
      },
      "location": {
        "path": "examples/ciphers.py",
        "start_line": 68,
        "end_line": 68,
        "start_column": 6,
        "end_column": 43
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/79/instances"
  },
  {
    "number": 78,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/78",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/78",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-cryptographic-algorithm",
      "severity": "warning",
      "description": "Use of a broken or weak cryptographic algorithm",
      "name": "py/weak-cryptographic-algorithm",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Using broken or weak cryptographic algorithms can compromise security.",
      "help": "# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\nThis query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.\n\n\n## Example\nThe following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.\n\n\n```python\nfrom Crypto.Cipher import DES, AES\n\ncipher = DES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # BAD: weak encryption\n\n\ncipher = AES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # GOOD: strong encryption\n\n\n```\nNOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).\n\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "The cryptographic algorithm DES is broken or weak, and should not be used."
      },
      "location": {
        "path": "examples/ciphers.py",
        "start_line": 57,
        "end_line": 57,
        "start_column": 15,
        "end_column": 40
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/78/instances"
  },
  {
    "number": 77,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/77",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/77",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-cryptographic-algorithm",
      "severity": "warning",
      "description": "Use of a broken or weak cryptographic algorithm",
      "name": "py/weak-cryptographic-algorithm",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Using broken or weak cryptographic algorithms can compromise security.",
      "help": "# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\nThis query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.\n\n\n## Example\nThe following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.\n\n\n```python\nfrom Crypto.Cipher import DES, AES\n\ncipher = DES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # BAD: weak encryption\n\n\ncipher = AES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # GOOD: strong encryption\n\n\n```\nNOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).\n\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "The cryptographic algorithm DES is broken or weak, and should not be used."
      },
      "location": {
        "path": "examples/ciphers.py",
        "start_line": 53,
        "end_line": 53,
        "start_column": 15,
        "end_column": 40
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/77/instances"
  },
  {
    "number": 76,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/76",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/76",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-cryptographic-algorithm",
      "severity": "warning",
      "description": "Use of a broken or weak cryptographic algorithm",
      "name": "py/weak-cryptographic-algorithm",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Using broken or weak cryptographic algorithms can compromise security.",
      "help": "# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\nThis query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.\n\n\n## Example\nThe following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.\n\n\n```python\nfrom Crypto.Cipher import DES, AES\n\ncipher = DES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # BAD: weak encryption\n\n\ncipher = AES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # GOOD: strong encryption\n\n\n```\nNOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).\n\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "The cryptographic algorithm ARC4 is broken or weak, and should not be used."
      },
      "location": {
        "path": "examples/ciphers.py",
        "start_line": 33,
        "end_line": 33,
        "start_column": 15,
        "end_column": 61
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/76/instances"
  },
  {
    "number": 75,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/75",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/75",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-cryptographic-algorithm",
      "severity": "warning",
      "description": "Use of a broken or weak cryptographic algorithm",
      "name": "py/weak-cryptographic-algorithm",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Using broken or weak cryptographic algorithms can compromise security.",
      "help": "# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\nThis query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.\n\n\n## Example\nThe following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.\n\n\n```python\nfrom Crypto.Cipher import DES, AES\n\ncipher = DES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # BAD: weak encryption\n\n\ncipher = AES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # GOOD: strong encryption\n\n\n```\nNOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).\n\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "The cryptographic algorithm ARC4 is broken or weak, and should not be used."
      },
      "location": {
        "path": "examples/ciphers.py",
        "start_line": 31,
        "end_line": 31,
        "start_column": 15,
        "end_column": 61
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/75/instances"
  },
  {
    "number": 74,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/74",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/74",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-cryptographic-algorithm",
      "severity": "warning",
      "description": "Use of a broken or weak cryptographic algorithm",
      "name": "py/weak-cryptographic-algorithm",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Using broken or weak cryptographic algorithms can compromise security.",
      "help": "# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\nThis query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.\n\n\n## Example\nThe following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.\n\n\n```python\nfrom Crypto.Cipher import DES, AES\n\ncipher = DES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # BAD: weak encryption\n\n\ncipher = AES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # GOOD: strong encryption\n\n\n```\nNOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).\n\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "The cryptographic algorithm ARC2 is broken or weak, and should not be used."
      },
      "location": {
        "path": "examples/ciphers.py",
        "start_line": 25,
        "end_line": 25,
        "start_column": 12,
        "end_column": 45
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/74/instances"
  },
  {
    "number": 73,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/73",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/73",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-cryptographic-algorithm",
      "severity": "warning",
      "description": "Use of a broken or weak cryptographic algorithm",
      "name": "py/weak-cryptographic-algorithm",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Using broken or weak cryptographic algorithms can compromise security.",
      "help": "# Use of a broken or weak cryptographic algorithm\nUsing broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.\n\nMany cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.\n\nThis query alerts on any use of a weak cryptographic algorithm, that is not a hashing algorithm. Use of broken or weak cryptographic hash functions are handled by the `py/weak-sensitive-data-hashing` query.\n\n\n## Recommendation\nEnsure that you use a strong, modern cryptographic algorithm, such as AES-128 or RSA-2048.\n\n\n## Example\nThe following code uses the `pycryptodome` library to encrypt some secret data. When you create a cipher using `pycryptodome` you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a stronger modern algorithm.\n\n\n```python\nfrom Crypto.Cipher import DES, AES\n\ncipher = DES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # BAD: weak encryption\n\n\ncipher = AES.new(SECRET_KEY)\n\ndef send_encrypted(channel, message):\n    channel.send(cipher.encrypt(message)) # GOOD: strong encryption\n\n\n```\nNOTICE: the original `[pycrypto](https://pypi.org/project/pycrypto/)` PyPI package that provided the `Crypto` module is not longer actively maintained, so you should use the `[pycryptodome](https://pypi.org/project/pycryptodome/)` PyPI package instead (which has a compatible API).\n\n\n## References\n* NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).\n* NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "The cryptographic algorithm ARC2 is broken or weak, and should not be used."
      },
      "location": {
        "path": "examples/ciphers.py",
        "start_line": 23,
        "end_line": 23,
        "start_column": 12,
        "end_column": 45
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/73/instances"
  },
  {
    "number": 72,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/72",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/72",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/insecure-default-protocol",
      "severity": "warning",
      "description": "Default version of SSL/TLS may be insecure",
      "name": "py/insecure-default-protocol",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Leaving the SSL/TLS version unspecified may result in an insecure default protocol being used.",
      "help": "# Default version of SSL/TLS may be insecure\nThe `ssl.wrap_socket` function defaults to an insecure version of SSL/TLS when no specific protocol version is specified. This may leave the connection vulnerable to attack.\n\n\n## Recommendation\nEnsure that a modern, strong protocol is used. All versions of SSL, and TLS 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended. If no explicit `ssl_version` is specified, the default `PROTOCOL_TLS` is chosen. This protocol is insecure because it allows TLS 1.0 and TLS 1.1 and so should not be used.\n\n\n## Example\nThe following code shows two different ways of setting up a connection using SSL or TLS. They are both potentially insecure because the default version is used.\n\n\n```python\nimport ssl\nimport socket\n\n# Using the deprecated ssl.wrap_socket method\nssl.wrap_socket(socket.socket())\n\n# Using SSLContext\ncontext = ssl.SSLContext()\n\n```\nBoth of the cases above should be updated to use a secure protocol instead, for instance by specifying `ssl_version=PROTOCOL_TLSv1_2` as a keyword argument.\n\nThe latter example can also be made secure by modifying the created context before it is used to create a connection. Therefore it will not be flagged by this query. However, if a connection is created before the context has been secured (for example, by setting the value of `minimum_version`), then the code should be flagged by the query `py/insecure-protocol`.\n\nNote that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:\n\n* `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions\n* `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.\nEven when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \\`minimum_version\\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.\n\n\n```python\nimport ssl\n\n# Using flags to restrict the protocol\ncontext = ssl.SSLContext()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n\n# Declaring a minimum version to restrict the protocol\ncontext = ssl.create_default_context()\ncontext.minimum_version = ssl.TLSVersion.TLSv1_2\n\n```\n\n## References\n* Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).\n* Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).\n* Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).\n* Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).\n* Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Call to deprecated method ssl.wrap_socket does not specify a protocol, which may result in an insecure default being used."
      },
      "location": {
        "path": "examples/ssl-insecure-version.py",
        "start_line": 30,
        "end_line": 30,
        "start_column": 1,
        "end_column": 18
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/72/instances"
  },
  {
    "number": 71,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/71",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/71",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/insecure-protocol",
      "severity": "warning",
      "description": "Use of insecure SSL/TLS version",
      "name": "py/insecure-protocol",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.",
      "help": "# Use of insecure SSL/TLS version\nUsing a broken or weak cryptographic protocol may make a connection vulnerable to interference from an attacker.\n\n\n## Recommendation\nEnsure that a modern, strong protocol is used. All versions of SSL, and TLS versions 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended.\n\n\n## Example\nThe following code shows a variety of ways of setting up a connection using SSL or TLS. They are all insecure because of the version specified.\n\n\n```python\nimport ssl\nimport socket\n\n# Using the deprecated ssl.wrap_socket method\nssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_SSLv2)\n\n# Using SSLContext\ncontext = ssl.SSLContext(ssl_version=ssl.PROTOCOL_SSLv3)\n\n# Using pyOpenSSL\n\nfrom pyOpenSSL import SSL\n\ncontext = SSL.Context(SSL.TLSv1_METHOD)\n\n\n\n```\nAll cases should be updated to use a secure protocol, such as `PROTOCOL_TLSv1_2`.\n\nNote that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:\n\n* `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions\n* `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.\nEven when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \\`minimum_version\\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.\n\n\n```python\nimport ssl\n\n# Using flags to restrict the protocol\ncontext = ssl.SSLContext()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n\n# Declaring a minimum version to restrict the protocol\ncontext = ssl.create_default_context()\ncontext.minimum_version = ssl.TLSVersion.TLSv1_2\n\n```\n\n## References\n* Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).\n* Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).\n* Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).\n* Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).\n* Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).\n* pyOpenSSL documentation: [ An interface to the SSL-specific parts of OpenSSL](https://pyopenssl.org/en/stable/api/ssl.html).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Insecure SSL/TLS protocol version TLSv1_1 specified by call to ssl.wrap_socket."
      },
      "location": {
        "path": "examples/ssl-insecure-version.py",
        "start_line": 23,
        "end_line": 23,
        "start_column": 1,
        "end_column": 50
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/71/instances"
  },
  {
    "number": 70,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/70",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/70",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/insecure-protocol",
      "severity": "warning",
      "description": "Use of insecure SSL/TLS version",
      "name": "py/insecure-protocol",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.",
      "help": "# Use of insecure SSL/TLS version\nUsing a broken or weak cryptographic protocol may make a connection vulnerable to interference from an attacker.\n\n\n## Recommendation\nEnsure that a modern, strong protocol is used. All versions of SSL, and TLS versions 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended.\n\n\n## Example\nThe following code shows a variety of ways of setting up a connection using SSL or TLS. They are all insecure because of the version specified.\n\n\n```python\nimport ssl\nimport socket\n\n# Using the deprecated ssl.wrap_socket method\nssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_SSLv2)\n\n# Using SSLContext\ncontext = ssl.SSLContext(ssl_version=ssl.PROTOCOL_SSLv3)\n\n# Using pyOpenSSL\n\nfrom pyOpenSSL import SSL\n\ncontext = SSL.Context(SSL.TLSv1_METHOD)\n\n\n\n```\nAll cases should be updated to use a secure protocol, such as `PROTOCOL_TLSv1_2`.\n\nNote that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:\n\n* `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions\n* `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.\nEven when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \\`minimum_version\\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.\n\n\n```python\nimport ssl\n\n# Using flags to restrict the protocol\ncontext = ssl.SSLContext()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n\n# Declaring a minimum version to restrict the protocol\ncontext = ssl.create_default_context()\ncontext.minimum_version = ssl.TLSVersion.TLSv1_2\n\n```\n\n## References\n* Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).\n* Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).\n* Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).\n* Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).\n* Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).\n* pyOpenSSL documentation: [ An interface to the SSL-specific parts of OpenSSL](https://pyopenssl.org/en/stable/api/ssl.html).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Insecure SSL/TLS protocol version TLSv1 specified by call to ssl.wrap_socket."
      },
      "location": {
        "path": "examples/ssl-insecure-version.py",
        "start_line": 14,
        "end_line": 14,
        "start_column": 1,
        "end_column": 48
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/70/instances"
  },
  {
    "number": 69,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/69",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/69",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/insecure-protocol",
      "severity": "warning",
      "description": "Use of insecure SSL/TLS version",
      "name": "py/insecure-protocol",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.",
      "help": "# Use of insecure SSL/TLS version\nUsing a broken or weak cryptographic protocol may make a connection vulnerable to interference from an attacker.\n\n\n## Recommendation\nEnsure that a modern, strong protocol is used. All versions of SSL, and TLS versions 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended.\n\n\n## Example\nThe following code shows a variety of ways of setting up a connection using SSL or TLS. They are all insecure because of the version specified.\n\n\n```python\nimport ssl\nimport socket\n\n# Using the deprecated ssl.wrap_socket method\nssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_SSLv2)\n\n# Using SSLContext\ncontext = ssl.SSLContext(ssl_version=ssl.PROTOCOL_SSLv3)\n\n# Using pyOpenSSL\n\nfrom pyOpenSSL import SSL\n\ncontext = SSL.Context(SSL.TLSv1_METHOD)\n\n\n\n```\nAll cases should be updated to use a secure protocol, such as `PROTOCOL_TLSv1_2`.\n\nNote that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:\n\n* `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions\n* `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.\nEven when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \\`minimum_version\\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.\n\n\n```python\nimport ssl\n\n# Using flags to restrict the protocol\ncontext = ssl.SSLContext()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n\n# Declaring a minimum version to restrict the protocol\ncontext = ssl.create_default_context()\ncontext.minimum_version = ssl.TLSVersion.TLSv1_2\n\n```\n\n## References\n* Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).\n* Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).\n* Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).\n* Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).\n* Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).\n* pyOpenSSL documentation: [ An interface to the SSL-specific parts of OpenSSL](https://pyopenssl.org/en/stable/api/ssl.html).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Insecure SSL/TLS protocol version SSLv3 specified by call to ssl.wrap_socket."
      },
      "location": {
        "path": "examples/ssl-insecure-version.py",
        "start_line": 13,
        "end_line": 13,
        "start_column": 1,
        "end_column": 48
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/69/instances"
  },
  {
    "number": 68,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/68",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/68",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/insecure-protocol",
      "severity": "warning",
      "description": "Use of insecure SSL/TLS version",
      "name": "py/insecure-protocol",
      "tags": ["external/cwe/cwe-327","security"],
      "full_description": "Using an insecure SSL/TLS version may leave the connection vulnerable to attacks.",
      "help": "# Use of insecure SSL/TLS version\nUsing a broken or weak cryptographic protocol may make a connection vulnerable to interference from an attacker.\n\n\n## Recommendation\nEnsure that a modern, strong protocol is used. All versions of SSL, and TLS versions 1.0 and 1.1 are known to be vulnerable to attacks. Using TLS 1.2 or above is strongly recommended.\n\n\n## Example\nThe following code shows a variety of ways of setting up a connection using SSL or TLS. They are all insecure because of the version specified.\n\n\n```python\nimport ssl\nimport socket\n\n# Using the deprecated ssl.wrap_socket method\nssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_SSLv2)\n\n# Using SSLContext\ncontext = ssl.SSLContext(ssl_version=ssl.PROTOCOL_SSLv3)\n\n# Using pyOpenSSL\n\nfrom pyOpenSSL import SSL\n\ncontext = SSL.Context(SSL.TLSv1_METHOD)\n\n\n\n```\nAll cases should be updated to use a secure protocol, such as `PROTOCOL_TLSv1_2`.\n\nNote that `ssl.wrap_socket` has been deprecated in Python 3.7. The recommended alternatives are:\n\n* `ssl.SSLContext` - supported in Python 2.7.9, 3.2, and later versions\n* `ssl.create_default_context` - a convenience function, supported in Python 3.4 and later versions.\nEven when you use these alternatives, you should ensure that a safe protocol is used. The following code illustrates how to use flags (available since Python 3.2) or the \\`minimum_version\\` field (favored since Python 3.7) to restrict the protocols accepted when creating a connection.\n\n\n```python\nimport ssl\n\n# Using flags to restrict the protocol\ncontext = ssl.SSLContext()\ncontext.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1\n\n# Declaring a minimum version to restrict the protocol\ncontext = ssl.create_default_context()\ncontext.minimum_version = ssl.TLSVersion.TLSv1_2\n\n```\n\n## References\n* Wikipedia: [ Transport Layer Security](https://en.wikipedia.org/wiki/Transport_Layer_Security).\n* Python 3 documentation: [ class ssl.SSLContext](https://docs.python.org/3/library/ssl.html#ssl.SSLContext).\n* Python 3 documentation: [ ssl.wrap_socket](https://docs.python.org/3/library/ssl.html#ssl.wrap_socket).\n* Python 3 documentation: [ notes on context creation](https://docs.python.org/3/library/ssl.html#functions-constants-and-exceptions).\n* Python 3 documentation: [ notes on security considerations](https://docs.python.org/3/library/ssl.html#ssl-security).\n* pyOpenSSL documentation: [ An interface to the SSL-specific parts of OpenSSL](https://pyopenssl.org/en/stable/api/ssl.html).\n* Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Insecure SSL/TLS protocol version SSLv2 specified by call to ssl.wrap_socket."
      },
      "location": {
        "path": "examples/ssl-insecure-version.py",
        "start_line": 4,
        "end_line": 4,
        "start_column": 1,
        "end_column": 48
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/68/instances"
  },
  {
    "number": 67,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/67",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/67",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/flask-debug",
      "severity": "error",
      "description": "Flask app is run in debug mode",
      "name": "py/flask-debug",
      "tags": ["external/cwe/cwe-215","external/cwe/cwe-489","security"],
      "full_description": "Running a Flask app in debug mode may allow an attacker to run arbitrary code through the Werkzeug debugger.",
      "help": "# Flask app is run in debug mode\nRunning a Flask application with debug mode enabled may allow an attacker to gain access through the Werkzeug debugger.\n\n\n## Recommendation\nEnsure that Flask applications that are run in a production environment have debugging disabled.\n\n\n## Example\nRunning the following code starts a Flask webserver that has debugging enabled. By visiting `/crash`, it is possible to gain access to the debugger, and run arbitrary code through the interactive debugger.\n\n\n```python\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.route('/crash')\ndef main():\n    raise Exception()\n\napp.run(debug=True)\n\n```\n\n## References\n* Flask Quickstart Documentation: [Debug Mode](http://flask.pocoo.org/docs/1.0/quickstart/#debug-mode).\n* Werkzeug Documentation: [Debugging Applications](http://werkzeug.pocoo.org/docs/0.14/debug/).\n* Common Weakness Enumeration: [CWE-215](https://cwe.mitre.org/data/definitions/215.html).\n* Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "A Flask app appears to be run in debug mode. This may allow an attacker to run arbitrary code through the debugger."
      },
      "location": {
        "path": "examples/flask_debug.py",
        "start_line": 10,
        "end_line": 10,
        "start_column": 1,
        "end_column": 20
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/67/instances"
  },
  {
    "number": 66,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/66",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/66",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/insecure-temporary-file",
      "severity": "error",
      "description": "Insecure temporary file",
      "name": "py/insecure-temporary-file",
      "tags": ["external/cwe/cwe-377","security"],
      "full_description": "Creating a temporary file using this method may be insecure.",
      "help": "# Insecure temporary file\nFunctions that create temporary file names (such as `tempfile.mktemp` and `os.tempnam`) are fundamentally insecure, as they do not ensure exclusive access to a file with the temporary name they return. The file name returned by these functions is guaranteed to be unique on creation but the file must be opened in a separate operation. There is no guarantee that the creation and open operations will happen atomically. This provides an opportunity for an attacker to interfere with the file before it is opened.\n\nNote that `mktemp` has been deprecated since Python 2.3.\n\n\n## Recommendation\nReplace the use of `mktemp` with some of the more secure functions in the `tempfile` module, such as `TemporaryFile`. If the file is intended to be accessed from other processes, consider using the `NamedTemporaryFile` function.\n\n\n## Example\nThe following piece of code opens a temporary file and writes a set of results to it. Because the file name is created using `mktemp`, another process may access this file before it is opened using `open`.\n\n\n```python\nfrom tempfile import mktemp\n\ndef write_results(results):\n    filename = mktemp()\n    with open(filename, \"w+\") as f:\n        f.write(results)\n    print(\"Results written to\", filename)\n\n```\nBy changing the code to use `NamedTemporaryFile` instead, the file is opened immediately.\n\n\n```python\nfrom tempfile import NamedTemporaryFile\n\ndef write_results(results):\n    with NamedTemporaryFile(mode=\"w+\", delete=False) as f:\n        f.write(results)\n    print(\"Results written to\", f.name)\n\n```\n\n## References\n* Python Standard Library: [tempfile.mktemp](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp).\n* Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Call to deprecated function tempfile.mktemp may be insecure."
      },
      "location": {
        "path": "examples/mktemp.py",
        "start_line": 10,
        "end_line": 10,
        "start_column": 1,
        "end_column": 16
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/66/instances"
  },
  {
    "number": 65,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/65",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/65",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/insecure-temporary-file",
      "severity": "error",
      "description": "Insecure temporary file",
      "name": "py/insecure-temporary-file",
      "tags": ["external/cwe/cwe-377","security"],
      "full_description": "Creating a temporary file using this method may be insecure.",
      "help": "# Insecure temporary file\nFunctions that create temporary file names (such as `tempfile.mktemp` and `os.tempnam`) are fundamentally insecure, as they do not ensure exclusive access to a file with the temporary name they return. The file name returned by these functions is guaranteed to be unique on creation but the file must be opened in a separate operation. There is no guarantee that the creation and open operations will happen atomically. This provides an opportunity for an attacker to interfere with the file before it is opened.\n\nNote that `mktemp` has been deprecated since Python 2.3.\n\n\n## Recommendation\nReplace the use of `mktemp` with some of the more secure functions in the `tempfile` module, such as `TemporaryFile`. If the file is intended to be accessed from other processes, consider using the `NamedTemporaryFile` function.\n\n\n## Example\nThe following piece of code opens a temporary file and writes a set of results to it. Because the file name is created using `mktemp`, another process may access this file before it is opened using `open`.\n\n\n```python\nfrom tempfile import mktemp\n\ndef write_results(results):\n    filename = mktemp()\n    with open(filename, \"w+\") as f:\n        f.write(results)\n    print(\"Results written to\", filename)\n\n```\nBy changing the code to use `NamedTemporaryFile` instead, the file is opened immediately.\n\n\n```python\nfrom tempfile import NamedTemporaryFile\n\ndef write_results(results):\n    with NamedTemporaryFile(mode=\"w+\", delete=False) as f:\n        f.write(results)\n    print(\"Results written to\", f.name)\n\n```\n\n## References\n* Python Standard Library: [tempfile.mktemp](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp).\n* Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Call to deprecated function tempfile.mktemp may be insecure."
      },
      "location": {
        "path": "examples/mktemp.py",
        "start_line": 9,
        "end_line": 9,
        "start_column": 1,
        "end_column": 8
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/65/instances"
  },
  {
    "number": 64,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/64",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/64",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/insecure-temporary-file",
      "severity": "error",
      "description": "Insecure temporary file",
      "name": "py/insecure-temporary-file",
      "tags": ["external/cwe/cwe-377","security"],
      "full_description": "Creating a temporary file using this method may be insecure.",
      "help": "# Insecure temporary file\nFunctions that create temporary file names (such as `tempfile.mktemp` and `os.tempnam`) are fundamentally insecure, as they do not ensure exclusive access to a file with the temporary name they return. The file name returned by these functions is guaranteed to be unique on creation but the file must be opened in a separate operation. There is no guarantee that the creation and open operations will happen atomically. This provides an opportunity for an attacker to interfere with the file before it is opened.\n\nNote that `mktemp` has been deprecated since Python 2.3.\n\n\n## Recommendation\nReplace the use of `mktemp` with some of the more secure functions in the `tempfile` module, such as `TemporaryFile`. If the file is intended to be accessed from other processes, consider using the `NamedTemporaryFile` function.\n\n\n## Example\nThe following piece of code opens a temporary file and writes a set of results to it. Because the file name is created using `mktemp`, another process may access this file before it is opened using `open`.\n\n\n```python\nfrom tempfile import mktemp\n\ndef write_results(results):\n    filename = mktemp()\n    with open(filename, \"w+\") as f:\n        f.write(results)\n    print(\"Results written to\", filename)\n\n```\nBy changing the code to use `NamedTemporaryFile` instead, the file is opened immediately.\n\n\n```python\nfrom tempfile import NamedTemporaryFile\n\ndef write_results(results):\n    with NamedTemporaryFile(mode=\"w+\", delete=False) as f:\n        f.write(results)\n    print(\"Results written to\", f.name)\n\n```\n\n## References\n* Python Standard Library: [tempfile.mktemp](https://docs.python.org/3/library/tempfile.html#tempfile.mktemp).\n* Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Call to deprecated function tempfile.mktemp may be insecure."
      },
      "location": {
        "path": "examples/mktemp.py",
        "start_line": 7,
        "end_line": 7,
        "start_column": 1,
        "end_column": 12
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/64/instances"
  },
  {
    "number": 63,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/63",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/63",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an RSA key uses 512 bits, which is below 2048 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 61,
        "end_line": 61,
        "start_column": 1,
        "end_column": 32
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/63/instances"
  },
  {
    "number": 62,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/62",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/62",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an DSA key uses 512 bits, which is below 2048 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 60,
        "end_line": 60,
        "start_column": 1,
        "end_column": 32
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/62/instances"
  },
  {
    "number": 61,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/61",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/61",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an RSA key uses 512 bits, which is below 2048 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 59,
        "end_line": 59,
        "start_column": 1,
        "end_column": 27
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/61/instances"
  },
  {
    "number": 60,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/60",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/60",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an DSA key uses 512 bits, which is below 2048 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 58,
        "end_line": 58,
        "start_column": 1,
        "end_column": 27
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/60/instances"
  },
  {
    "number": 59,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/59",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/59",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an RSA key uses 512 bits, which is below 2048 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 55,
        "end_line": 57,
        "start_column": 1,
        "end_column": 53
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/59/instances"
  },
  {
    "number": 58,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/58",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/58",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an ECC key uses 163 bits, which is below 256 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 53,
        "end_line": 54,
        "start_column": 1,
        "end_column": 52
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/58/instances"
  },
  {
    "number": 57,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/57",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/57",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an DSA key uses 512 bits, which is below 2048 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 51,
        "end_line": 52,
        "start_column": 1,
        "end_column": 53
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/57/instances"
  },
  {
    "number": 56,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/56",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/56",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an RSA key uses 1024 bits, which is below 2048 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 48,
        "end_line": 48,
        "start_column": 1,
        "end_column": 38
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/56/instances"
  },
  {
    "number": 55,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/55",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/55",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an DSA key uses 1024 bits, which is below 2048 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 47,
        "end_line": 47,
        "start_column": 1,
        "end_column": 38
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/55/instances"
  },
  {
    "number": 54,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/54",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/54",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an RSA key uses 1024 bits, which is below 2048 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 46,
        "end_line": 46,
        "start_column": 1,
        "end_column": 33
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/54/instances"
  },
  {
    "number": 53,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/53",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/53",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an DSA key uses 1024 bits, which is below 2048 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 45,
        "end_line": 45,
        "start_column": 1,
        "end_column": 33
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/53/instances"
  },
  {
    "number": 52,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/52",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/52",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an RSA key uses 1024 bits, which is below 2048 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 42,
        "end_line": 44,
        "start_column": 1,
        "end_column": 61
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/52/instances"
  },
  {
    "number": 51,
    "created_at": "2024-09-16T08:24:27Z",
    "updated_at": "2024-09-16T08:24:28Z",
    "url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/51",
    "html_url": "https://github.com/Be-Secure/bandit/security/code-scanning/51",
    "state": "open",
    "fixed_at": null,
    "dismissed_by": null,
    "dismissed_at": null,
    "dismissed_reason": null,
    "dismissed_comment": null,
    "rule": {
      "id": "py/weak-crypto-key",
      "severity": "error",
      "description": "Use of weak cryptographic key",
      "name": "py/weak-crypto-key",
      "tags": ["external/cwe/cwe-326","security"],
      "full_description": "Use of a cryptographic key that is too small may allow the encryption to be broken.",
      "help": "# Use of weak cryptographic key\nModern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.\n\nThe three main asymmetric key algorithms currently in use are Rivest–Shamir–Adleman (RSA) cryptography, Digital Signature Algorithm (DSA), and Elliptic-curve cryptography (ECC). With current technology, key sizes of 2048 bits for RSA and DSA, or 256 bits for ECC, are regarded as unbreakable.\n\n\n## Recommendation\nIncrease the key size to the recommended amount or larger. For RSA or DSA this is at least 2048 bits, for ECC this is at least 256 bits.\n\n\n## References\n* Wikipedia: [Digital Signature Algorithm](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm).\n* Wikipedia: [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).\n* Wikipedia: [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography).\n* Python cryptography module: [cryptography.io](https://cryptography.io/en/latest/).\n* NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).\n* Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).\n",
      "security_severity_level": "high"
    },
    "tool": {
      "name": "CodeQL",
      "guid": null,
      "version": "2.18.4"
    },
    "most_recent_instance": {
      "ref": "refs/heads/1.7.9_release",
      "analysis_key": ".github/workflows/codeql.yml:analyze",
      "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
      "category": "/language:python",
      "state": "open",
      "commit_sha": "7aa3044a84cefa2edc8a0b0310a3807178acde81",
      "message": {
        "text": "Creation of an ECC key uses 163 bits, which is below 256 and considered breakable."
      },
      "location": {
        "path": "examples/weak_cryptographic_key_sizes.py",
        "start_line": 40,
        "end_line": 41,
        "start_column": 1,
        "end_column": 60
      },
      "classifications": []
    },
    "instances_url": "https://api.github.com/repos/Be-Secure/bandit/code-scanning/alerts/51/instances"
  }
]