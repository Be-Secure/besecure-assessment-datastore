[
    {
      "number": 53,
      "created_at": "2024-08-14T06:10:23Z",
      "updated_at": "2024-08-14T06:10:23Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/53",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/53",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "py/bind-socket-all-network-interfaces",
        "severity": "error",
        "description": "Binding a socket to all network interfaces",
        "name": "py/bind-socket-all-network-interfaces",
        "tags": ["external/cwe/cwe-200","security"],
        "full_description": "Binding a socket to all interfaces opens it up to traffic from any IPv4 address and is therefore associated with security risks.",
        "help": "# Binding a socket to all network interfaces\nSockets can be used to communicate with other machines on a network. You can use the (IP address, port) pair to define the access restrictions for the socket you create. When using the built-in Python `socket` module (for instance, when building a message sender service or an FTP server data transmitter), one has to bind the port to some interface. When you bind the port to all interfaces using `0.0.0.0` as the IP address, you essentially allow it to accept connections from any IPv4 address provided that it can get to the socket via routing. Binding to all interfaces is therefore associated with security risks.\n\n\n## Recommendation\nBind your service incoming traffic only to a dedicated interface. If you need to bind more than one interface using the built-in `socket` module, create multiple sockets (instead of binding to one socket to all interfaces).\n\n\n## Example\nIn this example, two sockets are insecure because they are bound to all interfaces; one through the `0.0.0.0` notation and another one through an empty string `''`.\n\n\n```python\nimport socket\n\n# binds to all interfaces, insecure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('0.0.0.0', 31137))\n\n# binds to all interfaces, insecure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('', 4040))\n\n# binds only to a dedicated interface, secure\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('84.68.10.12', 8080))\n\n```\n\n## References\n* Python reference: [ Socket families](https://docs.python.org/3/library/socket.html#socket-families).\n* Python reference: [ Socket Programming HOWTO](https://docs.python.org/3.7/howto/sockets.html).\n* Common Vulnerabilities and Exposures: [ CVE-2018-1281 Detail](https://nvd.nist.gov/vuln/detail/CVE-2018-1281).\n* Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
        "category": "/language:python",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "'' binds a socket to all interfaces."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/wolfssl/wrapper/python/wolfssl/examples/server.py",
          "start_line": 107,
          "end_line": 107,
          "start_column": 5,
          "end_column": 62
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/53/instances"
    },
    {
      "number": 52,
      "created_at": "2024-08-14T06:10:23Z",
      "updated_at": "2024-08-14T06:10:23Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/52",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/52",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "py/redos",
        "severity": "error",
        "description": "Inefficient regular expression",
        "name": "py/redos",
        "tags": ["external/cwe/cwe-1333","external/cwe/cwe-400","external/cwe/cwe-730","security"],
        "full_description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
        "help": "# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Python uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this regular expression:\n\n```python\n\n^_(__|.)+_$\n```\nIts sub-expression `\"(__|.)+?\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```python\n\n^_(__|[^_])+_$\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
        "category": "/language:python",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This part of the regular expression may cause exponential backtracking on strings starting with ''' and containing many repetitions of '\\\\\\\\\\\\\\\\'."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/duktape/tools/scan_strings.py",
          "start_line": 37,
          "end_line": 37,
          "start_column": 35,
          "end_column": 55
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/52/instances"
    },
    {
      "number": 51,
      "created_at": "2024-08-14T06:10:23Z",
      "updated_at": "2024-08-14T06:10:23Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/51",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/51",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "py/redos",
        "severity": "error",
        "description": "Inefficient regular expression",
        "name": "py/redos",
        "tags": ["external/cwe/cwe-1333","external/cwe/cwe-400","external/cwe/cwe-730","security"],
        "full_description": "A regular expression that requires exponential time to match certain inputs can be a performance bottleneck, and may be vulnerable to denial-of-service attacks.",
        "help": "# Inefficient regular expression\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Python uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.\n\n\n## Example\nConsider this regular expression:\n\n```python\n\n^_(__|.)+_$\n```\nIts sub-expression `\"(__|.)+?\"` can match the string `\"__\"` either by the first alternative `\"__\"` to the left of the `\"|\"` operator, or by two repetitions of the second alternative `\".\"` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.\n\nThis problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:\n\n```python\n\n^_(__|[^_])+_$\n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"python\"}",
        "category": "/language:python",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This part of the regular expression may cause exponential backtracking on strings starting with '\"' and containing many repetitions of '\\\\\\\\\\\\\\\\'."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/duktape/tools/scan_strings.py",
          "start_line": 36,
          "end_line": 36,
          "start_column": 34,
          "end_column": 52
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/51/instances"
    },
    {
      "number": 50,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/50",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/50",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/prototype-pollution-utility",
        "severity": "warning",
        "description": "Prototype-polluting function",
        "name": "js/prototype-pollution-utility",
        "tags": ["external/cwe/cwe-078","external/cwe/cwe-079","external/cwe/cwe-094","external/cwe/cwe-400","external/cwe/cwe-471","external/cwe/cwe-915","security"],
        "full_description": "Functions recursively assigning properties on objects may be the cause of accidental modification of a built-in prototype object.",
        "help": "# Prototype-polluting function\nMost JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype`, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.\n\nOne way to cause prototype pollution is through use of an unsafe *merge* or *extend* function to recursively copy properties from one object to another, or through the use of a *deep assignment* function to assign to an unverified chain of property names. Such a function has the potential to modify any object reachable from the destination object, and the built-in `Object.prototype` is usually reachable through the special properties `__proto__` and `constructor.prototype`.\n\n\n## Recommendation\nThe most effective place to guard against this is in the function that performs the recursive copy or deep assignment.\n\nOnly merge or assign a property recursively when it is an own property of the *destination* object. Alternatively, block the property names `__proto__` and `constructor` from being merged or assigned to.\n\n\n## Example\nThis function recursively copies properties from `src` to `dst`:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\nHowever, if `src` is the object `{\"__proto__\": {\"isAdmin\": true}}`, it will inject the property `isAdmin: true` in `Object.prototype`.\n\nThe issue can be fixed by ensuring that only own properties of the destination object are merged recursively:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (dst.hasOwnProperty(key) && isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\nAlternatively, block the `__proto__` and `constructor` properties:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (key === \"__proto__\" || key === \"constructor\") continue;\n        if (isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\n\n## References\n* Prototype pollution attacks: [lodash](https://hackerone.com/reports/380873), [jQuery](https://hackerone.com/reports/454365), [extend](https://hackerone.com/reports/381185), [just-extend](https://hackerone.com/reports/430291), [merge.recursive](https://hackerone.com/reports/381194).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n* Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).\n* Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "Properties are copied from b9 to b5 without guarding against prototype pollution."
        },
        "location": {
          "path": "vehicle/OVMS.V3/html/jquery.js",
          "start_line": 16,
          "end_line": 16,
          "start_column": 3581,
          "end_column": 3583
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/50/instances"
    },
    {
      "number": 49,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/49",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/49",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/prototype-pollution-utility",
        "severity": "warning",
        "description": "Prototype-polluting function",
        "name": "js/prototype-pollution-utility",
        "tags": ["external/cwe/cwe-078","external/cwe/cwe-079","external/cwe/cwe-094","external/cwe/cwe-400","external/cwe/cwe-471","external/cwe/cwe-915","security"],
        "full_description": "Functions recursively assigning properties on objects may be the cause of accidental modification of a built-in prototype object.",
        "help": "# Prototype-polluting function\nMost JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype`, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.\n\nOne way to cause prototype pollution is through use of an unsafe *merge* or *extend* function to recursively copy properties from one object to another, or through the use of a *deep assignment* function to assign to an unverified chain of property names. Such a function has the potential to modify any object reachable from the destination object, and the built-in `Object.prototype` is usually reachable through the special properties `__proto__` and `constructor.prototype`.\n\n\n## Recommendation\nThe most effective place to guard against this is in the function that performs the recursive copy or deep assignment.\n\nOnly merge or assign a property recursively when it is an own property of the *destination* object. Alternatively, block the property names `__proto__` and `constructor` from being merged or assigned to.\n\n\n## Example\nThis function recursively copies properties from `src` to `dst`:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\nHowever, if `src` is the object `{\"__proto__\": {\"isAdmin\": true}}`, it will inject the property `isAdmin: true` in `Object.prototype`.\n\nThe issue can be fixed by ensuring that only own properties of the destination object are merged recursively:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (dst.hasOwnProperty(key) && isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\nAlternatively, block the `__proto__` and `constructor` properties:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (key === \"__proto__\" || key === \"constructor\") continue;\n        if (isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\n\n## References\n* Prototype pollution attacks: [lodash](https://hackerone.com/reports/380873), [jQuery](https://hackerone.com/reports/454365), [extend](https://hackerone.com/reports/381185), [just-extend](https://hackerone.com/reports/430291), [merge.recursive](https://hackerone.com/reports/381194).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n* Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).\n* Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "Properties are copied from a to e without guarding against prototype pollution."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/charts.js",
          "start_line": 15,
          "end_line": 15,
          "start_column": 344,
          "end_column": 345
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/49/instances"
    },
    {
      "number": 48,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/48",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/48",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/prototype-pollution-utility",
        "severity": "warning",
        "description": "Prototype-polluting function",
        "name": "js/prototype-pollution-utility",
        "tags": ["external/cwe/cwe-078","external/cwe/cwe-079","external/cwe/cwe-094","external/cwe/cwe-400","external/cwe/cwe-471","external/cwe/cwe-915","security"],
        "full_description": "Functions recursively assigning properties on objects may be the cause of accidental modification of a built-in prototype object.",
        "help": "# Prototype-polluting function\nMost JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype`, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.\n\nOne way to cause prototype pollution is through use of an unsafe *merge* or *extend* function to recursively copy properties from one object to another, or through the use of a *deep assignment* function to assign to an unverified chain of property names. Such a function has the potential to modify any object reachable from the destination object, and the built-in `Object.prototype` is usually reachable through the special properties `__proto__` and `constructor.prototype`.\n\n\n## Recommendation\nThe most effective place to guard against this is in the function that performs the recursive copy or deep assignment.\n\nOnly merge or assign a property recursively when it is an own property of the *destination* object. Alternatively, block the property names `__proto__` and `constructor` from being merged or assigned to.\n\n\n## Example\nThis function recursively copies properties from `src` to `dst`:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\nHowever, if `src` is the object `{\"__proto__\": {\"isAdmin\": true}}`, it will inject the property `isAdmin: true` in `Object.prototype`.\n\nThe issue can be fixed by ensuring that only own properties of the destination object are merged recursively:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (dst.hasOwnProperty(key) && isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\nAlternatively, block the `__proto__` and `constructor` properties:\n\n\n```javascript\nfunction merge(dst, src) {\n    for (let key in src) {\n        if (!src.hasOwnProperty(key)) continue;\n        if (key === \"__proto__\" || key === \"constructor\") continue;\n        if (isObject(dst[key])) {\n            merge(dst[key], src[key]);\n        } else {\n            dst[key] = src[key];\n        }\n    }\n}\n\n```\n\n## References\n* Prototype pollution attacks: [lodash](https://hackerone.com/reports/380873), [jQuery](https://hackerone.com/reports/454365), [extend](https://hackerone.com/reports/381185), [just-extend](https://hackerone.com/reports/430291), [merge.recursive](https://hackerone.com/reports/381194).\n* Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n* Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).\n* Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "Properties are copied from a to e without guarding against prototype pollution."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/highcharts.js",
          "start_line": 15,
          "end_line": 15,
          "start_column": 344,
          "end_column": 345
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/48/instances"
    },
    {
      "number": 47,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/47",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/47",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incorrect-suffix-check",
        "severity": "error",
        "description": "Incorrect suffix check",
        "name": "js/incorrect-suffix-check",
        "tags": ["correctness","external/cwe/cwe-020","security"],
        "full_description": "Using indexOf to implement endsWith functionality is error-prone if the -1 case is not explicitly handled.",
        "help": "# Incorrect suffix check\nThe `indexOf` and `lastIndexOf` methods are sometimes used to check if a substring occurs at a certain position in a string. However, if the returned index is compared to an expression that might evaluate to -1, the check may pass in some cases where the substring was not found at all.\n\nSpecifically, this can easily happen when implementing `endsWith` using `indexOf`.\n\n\n## Recommendation\nUse `String.prototype.endsWith` if it is available. Otherwise, explicitly handle the -1 case, either by checking the relative lengths of the strings, or by checking if the returned index is -1.\n\n\n## Example\nThe following example uses `lastIndexOf` to determine if the string `x` ends with the string `y`:\n\n\n```javascript\nfunction endsWith(x, y) {\n  return x.lastIndexOf(y) === x.length - y.length;\n}\n\n```\nHowever, if `y` is one character longer than `x`, the right-hand side `x.length - y.length` becomes -1, which then equals the return value of `lastIndexOf`. This will make the test pass, even though `x` does not end with `y`.\n\nTo avoid this, explicitly check for the -1 case:\n\n\n```javascript\nfunction endsWith(x, y) {\n  let index = x.lastIndexOf(y);\n  return index !== -1 && index === x.length - y.length;\n}\n\n```\n\n## References\n* MDN: [String.prototype.endsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)\n* MDN: [String.prototype.indexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This suffix check is missing a length comparison to correctly handle indexOf returning -1."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/charts.js",
          "start_line": 46,
          "end_line": 46,
          "start_column": 92,
          "end_column": 120
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/47/instances"
    },
    {
      "number": 46,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/46",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/46",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incorrect-suffix-check",
        "severity": "error",
        "description": "Incorrect suffix check",
        "name": "js/incorrect-suffix-check",
        "tags": ["correctness","external/cwe/cwe-020","security"],
        "full_description": "Using indexOf to implement endsWith functionality is error-prone if the -1 case is not explicitly handled.",
        "help": "# Incorrect suffix check\nThe `indexOf` and `lastIndexOf` methods are sometimes used to check if a substring occurs at a certain position in a string. However, if the returned index is compared to an expression that might evaluate to -1, the check may pass in some cases where the substring was not found at all.\n\nSpecifically, this can easily happen when implementing `endsWith` using `indexOf`.\n\n\n## Recommendation\nUse `String.prototype.endsWith` if it is available. Otherwise, explicitly handle the -1 case, either by checking the relative lengths of the strings, or by checking if the returned index is -1.\n\n\n## Example\nThe following example uses `lastIndexOf` to determine if the string `x` ends with the string `y`:\n\n\n```javascript\nfunction endsWith(x, y) {\n  return x.lastIndexOf(y) === x.length - y.length;\n}\n\n```\nHowever, if `y` is one character longer than `x`, the right-hand side `x.length - y.length` becomes -1, which then equals the return value of `lastIndexOf`. This will make the test pass, even though `x` does not end with `y`.\n\nTo avoid this, explicitly check for the -1 case:\n\n\n```javascript\nfunction endsWith(x, y) {\n  let index = x.lastIndexOf(y);\n  return index !== -1 && index === x.length - y.length;\n}\n\n```\n\n## References\n* MDN: [String.prototype.endsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)\n* MDN: [String.prototype.indexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This suffix check is missing a length comparison to correctly handle indexOf returning -1."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/highcharts.js",
          "start_line": 46,
          "end_line": 46,
          "start_column": 92,
          "end_column": 120
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/46/instances"
    },
    {
      "number": 45,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/45",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/45",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/unsafe-jquery-plugin",
        "severity": "warning",
        "description": "Unsafe jQuery plugin",
        "name": "js/unsafe-jquery-plugin",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","frameworks/jquery","security"],
        "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
        "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "Potential XSS vulnerability in the '$.fn.affix' plugin."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 12,
          "end_line": 12,
          "start_column": 2744,
          "end_column": 2763
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/45/instances"
    },
    {
      "number": 44,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/44",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/44",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/unsafe-jquery-plugin",
        "severity": "warning",
        "description": "Unsafe jQuery plugin",
        "name": "js/unsafe-jquery-plugin",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","frameworks/jquery","security"],
        "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
        "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "Potential XSS vulnerability in the '$.fn.scrollspy' plugin."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 12,
          "end_line": 12,
          "start_column": 300,
          "end_column": 313
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/44/instances"
    },
    {
      "number": 43,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/43",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/43",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/unsafe-jquery-plugin",
        "severity": "warning",
        "description": "Unsafe jQuery plugin",
        "name": "js/unsafe-jquery-plugin",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","frameworks/jquery","security"],
        "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
        "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "Potential XSS vulnerability in the '$.fn.scrollspy' plugin."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 12,
          "end_line": 12,
          "start_column": 114,
          "end_column": 115
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/43/instances"
    },
    {
      "number": 42,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/42",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/42",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/unsafe-jquery-plugin",
        "severity": "warning",
        "description": "Unsafe jQuery plugin",
        "name": "js/unsafe-jquery-plugin",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","frameworks/jquery","security"],
        "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
        "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "Potential XSS vulnerability in the '$.fn.tooltip' plugin."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 11,
          "end_line": 11,
          "start_column": 23779,
          "end_column": 23801
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/42/instances"
    },
    {
      "number": 41,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/41",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/41",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/unsafe-jquery-plugin",
        "severity": "warning",
        "description": "Unsafe jQuery plugin",
        "name": "js/unsafe-jquery-plugin",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","frameworks/jquery","security"],
        "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
        "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "Potential XSS vulnerability in the '$.fn.tooltip' plugin."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 11,
          "end_line": 11,
          "start_column": 20613,
          "end_column": 20749
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/41/instances"
    },
    {
      "number": 40,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/40",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/40",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/unsafe-jquery-plugin",
        "severity": "warning",
        "description": "Unsafe jQuery plugin",
        "name": "js/unsafe-jquery-plugin",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","frameworks/jquery","security"],
        "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
        "help": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "Potential XSS vulnerability in the '$.fn.collapse' plugin."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 11,
          "end_line": 11,
          "start_column": 10690,
          "end_column": 10709
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/40/instances"
    },
    {
      "number": 39,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/39",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/39",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/html-constructed-from-input",
        "severity": "error",
        "description": "Unsafe HTML constructed from library input",
        "name": "js/html-constructed-from-input",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Using externally controlled strings to construct HTML might allow a malicious user to perform a cross-site scripting attack.",
        "help": "# Unsafe HTML constructed from library input\nWhen a library function dynamically constructs HTML in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may inadvertently use inputs containing unsafe HTML fragments, and thereby leave the client vulnerable to cross-site scripting attacks.\n\n\n## Recommendation\nDocument all library functions that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example has a library function that renders a boldface name by writing to the `innerHTML` property of an element.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + name + \"</b>\";\n}\n\n```\nThis library function, however, does not escape unsafe HTML, and a client that calls the function with user-supplied input may be vulnerable to cross-site scripting attacks.\n\nThe library could either document that this function should not be used with unsafe inputs, or use safe APIs such as `innerText`.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  const bold = document.createElement('b');\n  bold.innerText = name;\n  document.getElementById('name').appendChild(bold);\n}\n\n```\nAlternatively, an HTML sanitizer can be used to remove unsafe content.\n\n\n```javascript\n\nconst striptags = require('striptags');\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + striptags(name) + \"</b>\";\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This HTML construction which depends on library input might later allow cross-site scripting."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 1006,
          "end_line": 1006,
          "start_column": 7,
          "end_column": 57
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/39/instances"
    },
    {
      "number": 38,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/38",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/38",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/html-constructed-from-input",
        "severity": "error",
        "description": "Unsafe HTML constructed from library input",
        "name": "js/html-constructed-from-input",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Using externally controlled strings to construct HTML might allow a malicious user to perform a cross-site scripting attack.",
        "help": "# Unsafe HTML constructed from library input\nWhen a library function dynamically constructs HTML in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may inadvertently use inputs containing unsafe HTML fragments, and thereby leave the client vulnerable to cross-site scripting attacks.\n\n\n## Recommendation\nDocument all library functions that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example has a library function that renders a boldface name by writing to the `innerHTML` property of an element.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + name + \"</b>\";\n}\n\n```\nThis library function, however, does not escape unsafe HTML, and a client that calls the function with user-supplied input may be vulnerable to cross-site scripting attacks.\n\nThe library could either document that this function should not be used with unsafe inputs, or use safe APIs such as `innerText`.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  const bold = document.createElement('b');\n  bold.innerText = name;\n  document.getElementById('name').appendChild(bold);\n}\n\n```\nAlternatively, an HTML sanitizer can be used to remove unsafe content.\n\n\n```javascript\n\nconst striptags = require('striptags');\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + striptags(name) + \"</b>\";\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This HTML construction which depends on library input might later allow cross-site scripting."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/ovms.js",
          "start_line": 579,
          "end_line": 579,
          "start_column": 7,
          "end_column": 57
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/38/instances"
    },
    {
      "number": 37,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/37",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/37",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/xss-through-dom",
        "severity": "warning",
        "description": "DOM text reinterpreted as HTML",
        "name": "js/xss-through-dom",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
        "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/dev/plugin-twizy/drivemode-config.htm",
          "start_line": 229,
          "end_line": 235,
          "start_column": 18,
          "end_column": 80
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/37/instances"
    },
    {
      "number": 36,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/36",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/36",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/xss-through-dom",
        "severity": "warning",
        "description": "DOM text reinterpreted as HTML",
        "name": "js/xss-through-dom",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
        "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 11,
          "end_line": 11,
          "start_column": 25357,
          "end_column": 25358
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/36/instances"
    },
    {
      "number": 35,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/35",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/35",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/xss-through-dom",
        "severity": "warning",
        "description": "DOM text reinterpreted as HTML",
        "name": "js/xss-through-dom",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
        "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 11,
          "end_line": 11,
          "start_column": 19409,
          "end_column": 19465
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/35/instances"
    },
    {
      "number": 34,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/34",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/34",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/xss-through-dom",
        "severity": "warning",
        "description": "DOM text reinterpreted as HTML",
        "name": "js/xss-through-dom",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
        "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 11,
          "end_line": 11,
          "start_column": 11535,
          "end_column": 11536
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/34/instances"
    },
    {
      "number": 33,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/33",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/33",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/xss-through-dom",
        "severity": "warning",
        "description": "DOM text reinterpreted as HTML",
        "name": "js/xss-through-dom",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
        "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 11,
          "end_line": 11,
          "start_column": 8140,
          "end_column": 8141
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/33/instances"
    },
    {
      "number": 32,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/32",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/32",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/xss-through-dom",
        "severity": "warning",
        "description": "DOM text reinterpreted as HTML",
        "name": "js/xss-through-dom",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
        "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 11,
          "end_line": 11,
          "start_column": 7525,
          "end_column": 7598
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/32/instances"
    },
    {
      "number": 31,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/31",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/31",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/xss-through-dom",
        "severity": "warning",
        "description": "DOM text reinterpreted as HTML",
        "name": "js/xss-through-dom",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
        "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 11,
          "end_line": 11,
          "start_column": 1567,
          "end_column": 1579
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/31/instances"
    },
    {
      "number": 30,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/30",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/30",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/xss-through-dom",
        "severity": "warning",
        "description": "DOM text reinterpreted as HTML",
        "name": "js/xss-through-dom",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
        "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
        },
        "location": {
          "path": "plugin/repidscan/repidscan.htm",
          "start_line": 312,
          "end_line": 312,
          "start_column": 31,
          "end_column": 33
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/30/instances"
    },
    {
      "number": 29,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/29",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/29",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/xss-through-dom",
        "severity": "warning",
        "description": "DOM text reinterpreted as HTML",
        "name": "js/xss-through-dom",
        "tags": ["external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
        "help": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "DOM text is reinterpreted as HTML without escaping meta-characters."
        },
        "location": {
          "path": "plugin/repidscan/repidscan.htm",
          "start_line": 311,
          "end_line": 311,
          "start_column": 32,
          "end_column": 34
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/29/instances"
    },
    {
      "number": 28,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/28",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/28",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/path-injection",
        "severity": "error",
        "description": "Uncontrolled data used in path expression",
        "name": "js/path-injection",
        "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nThe validation method you should use depends on whether you want to allow the user to specify complex paths with multiple components that may span multiple folders, or only simple filenames without a path component.\n\nIn the former case, a common strategy is to make sure that the constructed file path is contained within a safe root folder. First, normalize the path using `path.resolve` or `fs.realpathSync` to remove any \"..\" segments. You should always normalize the file path since an unnormalized path that starts with the root folder can still be used to access files outside the root folder. Then, after you have normalized the path, check that the path starts with the root folder.\n\nIn the latter case, you can use a library like the `sanitize-filename` npm package to eliminate any special characters from the file path. Note that it is *not* sufficient to only remove \"../\" sequences: for example, applying this filter to \".../...//\" would still result in the string \"../\".\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first (bad) example, the code reads the file name from an HTTP request, then accesses that file within a root folder. A malicious user could enter a file name containing \"../\" segments to navigate outside the root folder and access sensitive files.\n\n\n```javascript\nconst fs = require('fs'),\n      http = require('http'),\n      url = require('url');\n\nconst ROOT = \"/var/www/\";\n\nvar server = http.createServer(function(req, res) {\n  let filePath = url.parse(req.url, true).query.path;\n\n  // BAD: This function uses unsanitized input that can read any file on the file system.\n  res.write(fs.readFileSync(ROOT + filePath, 'utf8'));\n});\n```\nThe second (good) example shows how to avoid access to sensitive files by sanitizing the file path. First, the code resolves the file name relative to a root folder, normalizing the path and removing any \"../\" segments in the process. Then, the code calls `fs.realpathSync` to resolve any symbolic links in the path. Finally, the code checks that the normalized path starts with the path of the root folder, ensuring the file is contained within the root folder.\n\n\n```javascript\nconst fs = require('fs'),\n      http = require('http'),\n      path = require('path'),\n      url = require('url');\n\nconst ROOT = \"/var/www/\";\n\nvar server = http.createServer(function(req, res) {\n  let filePath = url.parse(req.url, true).query.path;\n\n  // GOOD: Verify that the file path is under the root directory\n  filePath = fs.realpathSync(path.resolve(ROOT, filePath));\n  if (!filePath.startsWith(ROOT)) {\n    res.statusCode = 403;\n    res.end();\n    return;\n  }\n  res.write(fs.readFileSync(filePath, 'utf8'));\n});\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* npm: [sanitize-filename](https://www.npmjs.com/package/sanitize-filename) package.\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This path depends on a user-provided value."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/duktape/debugger/duk_debug.js",
          "start_line": 504,
          "end_line": 504,
          "start_column": 40,
          "end_column": 42
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/28/instances"
    },
    {
      "number": 27,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/27",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/27",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/path-injection",
        "severity": "error",
        "description": "Uncontrolled data used in path expression",
        "name": "js/path-injection",
        "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nThe validation method you should use depends on whether you want to allow the user to specify complex paths with multiple components that may span multiple folders, or only simple filenames without a path component.\n\nIn the former case, a common strategy is to make sure that the constructed file path is contained within a safe root folder. First, normalize the path using `path.resolve` or `fs.realpathSync` to remove any \"..\" segments. You should always normalize the file path since an unnormalized path that starts with the root folder can still be used to access files outside the root folder. Then, after you have normalized the path, check that the path starts with the root folder.\n\nIn the latter case, you can use a library like the `sanitize-filename` npm package to eliminate any special characters from the file path. Note that it is *not* sufficient to only remove \"../\" sequences: for example, applying this filter to \".../...//\" would still result in the string \"../\".\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first (bad) example, the code reads the file name from an HTTP request, then accesses that file within a root folder. A malicious user could enter a file name containing \"../\" segments to navigate outside the root folder and access sensitive files.\n\n\n```javascript\nconst fs = require('fs'),\n      http = require('http'),\n      url = require('url');\n\nconst ROOT = \"/var/www/\";\n\nvar server = http.createServer(function(req, res) {\n  let filePath = url.parse(req.url, true).query.path;\n\n  // BAD: This function uses unsanitized input that can read any file on the file system.\n  res.write(fs.readFileSync(ROOT + filePath, 'utf8'));\n});\n```\nThe second (good) example shows how to avoid access to sensitive files by sanitizing the file path. First, the code resolves the file name relative to a root folder, normalizing the path and removing any \"../\" segments in the process. Then, the code calls `fs.realpathSync` to resolve any symbolic links in the path. Finally, the code checks that the normalized path starts with the path of the root folder, ensuring the file is contained within the root folder.\n\n\n```javascript\nconst fs = require('fs'),\n      http = require('http'),\n      path = require('path'),\n      url = require('url');\n\nconst ROOT = \"/var/www/\";\n\nvar server = http.createServer(function(req, res) {\n  let filePath = url.parse(req.url, true).query.path;\n\n  // GOOD: Verify that the file path is under the root directory\n  filePath = fs.realpathSync(path.resolve(ROOT, filePath));\n  if (!filePath.startsWith(ROOT)) {\n    res.statusCode = 403;\n    res.end();\n    return;\n  }\n  res.write(fs.readFileSync(filePath, 'utf8'));\n});\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* npm: [sanitize-filename](https://www.npmjs.com/package/sanitize-filename) package.\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This path depends on a user-provided value."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/duktape/debugger/duk_debug.js",
          "start_line": 503,
          "end_line": 503,
          "start_column": 51,
          "end_column": 53
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/27/instances"
    },
    {
      "number": 26,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/26",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/26",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/path-injection",
        "severity": "error",
        "description": "Uncontrolled data used in path expression",
        "name": "js/path-injection",
        "tags": ["external/cwe/cwe-022","external/cwe/cwe-023","external/cwe/cwe-036","external/cwe/cwe-073","external/cwe/cwe-099","security"],
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "help": "# Uncontrolled data used in path expression\nAccessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nThe validation method you should use depends on whether you want to allow the user to specify complex paths with multiple components that may span multiple folders, or only simple filenames without a path component.\n\nIn the former case, a common strategy is to make sure that the constructed file path is contained within a safe root folder. First, normalize the path using `path.resolve` or `fs.realpathSync` to remove any \"..\" segments. You should always normalize the file path since an unnormalized path that starts with the root folder can still be used to access files outside the root folder. Then, after you have normalized the path, check that the path starts with the root folder.\n\nIn the latter case, you can use a library like the `sanitize-filename` npm package to eliminate any special characters from the file path. Note that it is *not* sufficient to only remove \"../\" sequences: for example, applying this filter to \".../...//\" would still result in the string \"../\".\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn the first (bad) example, the code reads the file name from an HTTP request, then accesses that file within a root folder. A malicious user could enter a file name containing \"../\" segments to navigate outside the root folder and access sensitive files.\n\n\n```javascript\nconst fs = require('fs'),\n      http = require('http'),\n      url = require('url');\n\nconst ROOT = \"/var/www/\";\n\nvar server = http.createServer(function(req, res) {\n  let filePath = url.parse(req.url, true).query.path;\n\n  // BAD: This function uses unsanitized input that can read any file on the file system.\n  res.write(fs.readFileSync(ROOT + filePath, 'utf8'));\n});\n```\nThe second (good) example shows how to avoid access to sensitive files by sanitizing the file path. First, the code resolves the file name relative to a root folder, normalizing the path and removing any \"../\" segments in the process. Then, the code calls `fs.realpathSync` to resolve any symbolic links in the path. Finally, the code checks that the normalized path starts with the path of the root folder, ensuring the file is contained within the root folder.\n\n\n```javascript\nconst fs = require('fs'),\n      http = require('http'),\n      path = require('path'),\n      url = require('url');\n\nconst ROOT = \"/var/www/\";\n\nvar server = http.createServer(function(req, res) {\n  let filePath = url.parse(req.url, true).query.path;\n\n  // GOOD: Verify that the file path is under the root directory\n  filePath = fs.realpathSync(path.resolve(ROOT, filePath));\n  if (!filePath.startsWith(ROOT)) {\n    res.statusCode = 403;\n    res.end();\n    return;\n  }\n  res.write(fs.readFileSync(filePath, 'utf8'));\n});\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* npm: [sanitize-filename](https://www.npmjs.com/package/sanitize-filename) package.\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n* Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This path depends on a user-provided value."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/duktape/debugger/duk_debug.js",
          "start_line": 503,
          "end_line": 503,
          "start_column": 31,
          "end_column": 33
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/26/instances"
    },
    {
      "number": 25,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/25",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/25",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This does not escape backslash characters in the input."
        },
        "location": {
          "path": "vehicle/OVMS.V3/html/jquery.js",
          "start_line": 23,
          "end_line": 23,
          "start_column": 14251,
          "end_column": 14261
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/25/instances"
    },
    {
      "number": 24,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/24",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/24",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This does not escape backslash characters in the input."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/retools/web/retools.htm",
          "start_line": 160,
          "end_line": 160,
          "start_column": 19,
          "end_column": 33
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/24/instances"
    },
    {
      "number": 23,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/23",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/23",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This does not escape backslash characters in the input."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/dev/plugin-twizy/profile-editor.htm",
          "start_line": 577,
          "end_line": 577,
          "start_column": 15,
          "end_column": 46
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/23/instances"
    },
    {
      "number": 22,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/22",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/22",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This does not escape backslash characters in the input."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/dev/plugin-twizy/profile-editor.htm",
          "start_line": 576,
          "end_line": 576,
          "start_column": 15,
          "end_column": 46
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/22/instances"
    },
    {
      "number": 21,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/21",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/21",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This replaces only the first occurrence of \"*\"."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 230,
          "end_line": 230,
          "start_column": 63,
          "end_column": 72
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/21/instances"
    },
    {
      "number": 20,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/20",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/20",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This replaces only the first occurrence of \"*\"."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 229,
          "end_line": 229,
          "start_column": 383,
          "end_column": 392
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/20/instances"
    },
    {
      "number": 19,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/19",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/19",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This replaces only the first occurrence of '\"'."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 56,
          "end_line": 56,
          "start_column": 488,
          "end_column": 497
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/19/instances"
    },
    {
      "number": 18,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/18",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/18",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This does not escape backslash characters in the input."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/charts.js",
          "start_line": 59,
          "end_line": 60,
          "start_column": 454,
          "end_column": 12
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/18/instances"
    },
    {
      "number": 17,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/17",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/17",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This does not escape backslash characters in the input."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/highcharts.js",
          "start_line": 59,
          "end_line": 60,
          "start_column": 454,
          "end_column": 12
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/17/instances"
    },
    {
      "number": 16,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/16",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/16",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This does not escape backslash characters in the input."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_script/jsmodsrc/json.js",
          "start_line": 25,
          "end_line": 25,
          "start_column": 20,
          "end_column": 31
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/16/instances"
    },
    {
      "number": 15,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/15",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/15",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This does not escape backslash characters in the input."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_script/jsmodembed/json.js",
          "start_line": 1,
          "end_line": 1,
          "start_column": 220,
          "end_column": 229
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/15/instances"
    },
    {
      "number": 14,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/14",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/14",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-sanitization",
        "severity": "warning",
        "description": "Incomplete string escaping or encoding",
        "name": "js/incomplete-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "help": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This does not escape backslash characters in the input."
        },
        "location": {
          "path": "plugins/retools/retools.htm",
          "start_line": 169,
          "end_line": 169,
          "start_column": 19,
          "end_column": 33
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/14/instances"
    },
    {
      "number": 13,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/13",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/13",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/unsafe-html-expansion",
        "severity": "warning",
        "description": "Unsafe expansion of self-closing HTML tag",
        "name": "js/unsafe-html-expansion",
        "tags": ["correctness","external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Using regular expressions to expand self-closing HTML tags may lead to cross-site scripting vulnerabilities.",
        "help": "# Unsafe expansion of self-closing HTML tag\nSanitizing untrusted input for HTML meta-characters is a common technique for preventing cross-site scripting attacks. But even a sanitized input can be dangerous to use if it is modified further before a browser treats it as HTML. A seemingly innocent transformation that expands a self-closing HTML tag from `<div attr=\"{sanitized}\"/>` to `<div attr=\"{sanitized}\"></div>` may in fact cause cross-site scripting vulnerabilities.\n\n\n## Recommendation\nUse a well-tested sanitization library if at all possible, and avoid modifying sanitized values further before treating them as HTML.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using HTML templates that are explicit about the values they treat as HTML.\n\n\n## Example\nThe following function transforms a self-closing HTML tag to a pair of open/close tags. It does so for all non-`img` and non-`area` tags, by using a regular expression with two capture groups. The first capture group corresponds to the name of the tag, and the second capture group to the content of the tag.\n\n\n```javascript\nfunction expandSelfClosingTags(html) {\n\tvar rxhtmlTag = /<(?!img|area)(([a-z][^\\w\\/>]*)[^>]*)\\/>/gi;\n\treturn html.replace(rxhtmlTag, \"<$1></$2>\"); // BAD\n}\n\n```\nWhile it is generally known regular expressions are ill-suited for parsing HTML, variants of this particular transformation pattern have long been considered safe.\n\nHowever, the function is not safe. As an example, consider the following string:\n\n\n```html\n<div alt=\"\n<x\" title=\"/>\n<img src=url404 onerror=alert(1)>\"/>\n\n```\nWhen the above function transforms the string, it becomes a string that results in an alert when a browser treats it as HTML.\n\n\n```html\n<div alt=\"\n<x\" title=\"></x\" >\n<img src=url404 onerror=alert(1)>\"/>\n\n```\n\n## References\n* jQuery: [Security fixes in jQuery 3.5.0](https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/)\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This self-closing HTML tag expansion invalidates prior sanitization as this regular expression may match part of an attribute value."
        },
        "location": {
          "path": "vehicle/OVMS.V3/html/jquery.js",
          "start_line": 23,
          "end_line": 23,
          "start_column": 29685,
          "end_column": 29710
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/13/instances"
    },
    {
      "number": 12,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/12",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/12",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/unsafe-html-expansion",
        "severity": "warning",
        "description": "Unsafe expansion of self-closing HTML tag",
        "name": "js/unsafe-html-expansion",
        "tags": ["correctness","external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Using regular expressions to expand self-closing HTML tags may lead to cross-site scripting vulnerabilities.",
        "help": "# Unsafe expansion of self-closing HTML tag\nSanitizing untrusted input for HTML meta-characters is a common technique for preventing cross-site scripting attacks. But even a sanitized input can be dangerous to use if it is modified further before a browser treats it as HTML. A seemingly innocent transformation that expands a self-closing HTML tag from `<div attr=\"{sanitized}\"/>` to `<div attr=\"{sanitized}\"></div>` may in fact cause cross-site scripting vulnerabilities.\n\n\n## Recommendation\nUse a well-tested sanitization library if at all possible, and avoid modifying sanitized values further before treating them as HTML.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using HTML templates that are explicit about the values they treat as HTML.\n\n\n## Example\nThe following function transforms a self-closing HTML tag to a pair of open/close tags. It does so for all non-`img` and non-`area` tags, by using a regular expression with two capture groups. The first capture group corresponds to the name of the tag, and the second capture group to the content of the tag.\n\n\n```javascript\nfunction expandSelfClosingTags(html) {\n\tvar rxhtmlTag = /<(?!img|area)(([a-z][^\\w\\/>]*)[^>]*)\\/>/gi;\n\treturn html.replace(rxhtmlTag, \"<$1></$2>\"); // BAD\n}\n\n```\nWhile it is generally known regular expressions are ill-suited for parsing HTML, variants of this particular transformation pattern have long been considered safe.\n\nHowever, the function is not safe. As an example, consider the following string:\n\n\n```html\n<div alt=\"\n<x\" title=\"/>\n<img src=url404 onerror=alert(1)>\"/>\n\n```\nWhen the above function transforms the string, it becomes a string that results in an alert when a browser treats it as HTML.\n\n\n```html\n<div alt=\"\n<x\" title=\"></x\" >\n<img src=url404 onerror=alert(1)>\"/>\n\n```\n\n## References\n* jQuery: [Security fixes in jQuery 3.5.0](https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/)\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This self-closing HTML tag expansion invalidates prior sanitization as this regular expression may match part of an attribute value."
        },
        "location": {
          "path": "vehicle/OVMS.V3/html/jquery.js",
          "start_line": 23,
          "end_line": 23,
          "start_column": 24775,
          "end_column": 24800
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/12/instances"
    },
    {
      "number": 11,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/11",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/11",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/unsafe-html-expansion",
        "severity": "warning",
        "description": "Unsafe expansion of self-closing HTML tag",
        "name": "js/unsafe-html-expansion",
        "tags": ["correctness","external/cwe/cwe-079","external/cwe/cwe-116","security"],
        "full_description": "Using regular expressions to expand self-closing HTML tags may lead to cross-site scripting vulnerabilities.",
        "help": "# Unsafe expansion of self-closing HTML tag\nSanitizing untrusted input for HTML meta-characters is a common technique for preventing cross-site scripting attacks. But even a sanitized input can be dangerous to use if it is modified further before a browser treats it as HTML. A seemingly innocent transformation that expands a self-closing HTML tag from `<div attr=\"{sanitized}\"/>` to `<div attr=\"{sanitized}\"></div>` may in fact cause cross-site scripting vulnerabilities.\n\n\n## Recommendation\nUse a well-tested sanitization library if at all possible, and avoid modifying sanitized values further before treating them as HTML.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using HTML templates that are explicit about the values they treat as HTML.\n\n\n## Example\nThe following function transforms a self-closing HTML tag to a pair of open/close tags. It does so for all non-`img` and non-`area` tags, by using a regular expression with two capture groups. The first capture group corresponds to the name of the tag, and the second capture group to the content of the tag.\n\n\n```javascript\nfunction expandSelfClosingTags(html) {\n\tvar rxhtmlTag = /<(?!img|area)(([a-z][^\\w\\/>]*)[^>]*)\\/>/gi;\n\treturn html.replace(rxhtmlTag, \"<$1></$2>\"); // BAD\n}\n\n```\nWhile it is generally known regular expressions are ill-suited for parsing HTML, variants of this particular transformation pattern have long been considered safe.\n\nHowever, the function is not safe. As an example, consider the following string:\n\n\n```html\n<div alt=\"\n<x\" title=\"/>\n<img src=url404 onerror=alert(1)>\"/>\n\n```\nWhen the above function transforms the string, it becomes a string that results in an alert when a browser treats it as HTML.\n\n\n```html\n<div alt=\"\n<x\" title=\"></x\" >\n<img src=url404 onerror=alert(1)>\"/>\n\n```\n\n## References\n* jQuery: [Security fixes in jQuery 3.5.0](https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/)\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "medium"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This self-closing HTML tag expansion invalidates prior sanitization as this regular expression may match part of an attribute value."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/script.js",
          "start_line": 3,
          "end_line": 3,
          "start_column": 21608,
          "end_column": 21633
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/11/instances"
    },
    {
      "number": 10,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/10",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/10",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-multi-character-sanitization",
        "severity": "warning",
        "description": "Incomplete multi-character sanitization",
        "name": "js/incomplete-multi-character-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This string may still contain <script, which may cause an HTML element injection vulnerability."
        },
        "location": {
          "path": "vehicle/OVMS.V3/html/jquery.js",
          "start_line": 23,
          "end_line": 23,
          "start_column": 37781,
          "end_column": 37798
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/10/instances"
    },
    {
      "number": 9,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/9",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/9",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-multi-character-sanitization",
        "severity": "warning",
        "description": "Incomplete multi-character sanitization",
        "name": "js/incomplete-multi-character-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This string may still contain <!--, which may cause an HTML element injection vulnerability."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 252,
          "end_line": 253,
          "start_column": 500,
          "end_column": 101
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/9/instances"
    },
    {
      "number": 8,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/8",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/8",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-multi-character-sanitization",
        "severity": "warning",
        "description": "Incomplete multi-character sanitization",
        "name": "js/incomplete-multi-character-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This string may still contain <script, which may cause an HTML element injection vulnerability."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 252,
          "end_line": 253,
          "start_column": 500,
          "end_column": 122
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/8/instances"
    },
    {
      "number": 7,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/7",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/7",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-multi-character-sanitization",
        "severity": "warning",
        "description": "Incomplete multi-character sanitization",
        "name": "js/incomplete-multi-character-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This string may still contain <!--, which may cause an HTML element injection vulnerability."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 231,
          "end_line": 231,
          "start_column": 425,
          "end_column": 456
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/7/instances"
    },
    {
      "number": 6,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/6",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/6",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-multi-character-sanitization",
        "severity": "warning",
        "description": "Incomplete multi-character sanitization",
        "name": "js/incomplete-multi-character-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This string may still contain <script, which may cause an HTML element injection vulnerability."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 231,
          "end_line": 231,
          "start_column": 355,
          "end_column": 422
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/6/instances"
    },
    {
      "number": 5,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/5",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/5",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-multi-character-sanitization",
        "severity": "warning",
        "description": "Incomplete multi-character sanitization",
        "name": "js/incomplete-multi-character-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This string may still contain <script, which may cause an HTML element injection vulnerability."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 171,
          "end_line": 171,
          "start_column": 14,
          "end_column": 36
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/5/instances"
    },
    {
      "number": 4,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/4",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/4",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-multi-character-sanitization",
        "severity": "warning",
        "description": "Incomplete multi-character sanitization",
        "name": "js/incomplete-multi-character-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This string may still contain <script, which may cause an HTML element injection vulnerability."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 170,
          "end_line": 170,
          "start_column": 136,
          "end_column": 168
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/4/instances"
    },
    {
      "number": 3,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/3",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/3",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-multi-character-sanitization",
        "severity": "warning",
        "description": "Incomplete multi-character sanitization",
        "name": "js/incomplete-multi-character-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This string may still contain <script, which may cause an HTML element injection vulnerability."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 106,
          "end_line": 106,
          "start_column": 368,
          "end_column": 384
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/3/instances"
    },
    {
      "number": 2,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/2",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/2",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-multi-character-sanitization",
        "severity": "warning",
        "description": "Incomplete multi-character sanitization",
        "name": "js/incomplete-multi-character-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This string may still contain <script, which may cause an HTML element injection vulnerability."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 80,
          "end_line": 80,
          "start_column": 195,
          "end_column": 224
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/2/instances"
    },
    {
      "number": 1,
      "created_at": "2024-08-14T06:10:08Z",
      "updated_at": "2024-08-14T06:10:10Z",
      "url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/1",
      "html_url": "https://github.com/Be-Secure/Open-Vehicle-Monitoring-System-3/security/code-scanning/1",
      "state": "open",
      "fixed_at": null,
      "dismissed_by": null,
      "dismissed_at": null,
      "dismissed_reason": null,
      "dismissed_comment": null,
      "rule": {
        "id": "js/incomplete-multi-character-sanitization",
        "severity": "warning",
        "description": "Incomplete multi-character sanitization",
        "name": "js/incomplete-multi-character-sanitization",
        "tags": ["correctness","external/cwe/cwe-020","external/cwe/cwe-080","external/cwe/cwe-116","security"],
        "full_description": "A sanitizer that removes a sequence of characters may reintroduce the dangerous sequence.",
        "help": "# Incomplete multi-character sanitization\nSanitizing untrusted input is a common technique for preventing injection attacks and other security vulnerabilities. Regular expressions are often used to perform this sanitization. However, when the regular expression matches multiple consecutive characters, replacing it just once can result in the unsafe text reappearing in the sanitized input.\n\nAttackers can exploit this issue by crafting inputs that, when sanitized with an ineffective regular expression, still contain malicious code or content. This can lead to code execution, data exposure, or other vulnerabilities.\n\n\n## Recommendation\nTo prevent this issue, it is highly recommended to use a well-tested sanitization library whenever possible. These libraries are more likely to handle corner cases and ensure effective sanitization.\n\nIf a library is not an option, you can consider alternative strategies to fix the issue. For example, applying the regular expression replacement repeatedly until no more replacements can be performed, or rewriting the regular expression to match single characters instead of the entire unsafe text.\n\n\n## Example\nConsider the following JavaScript code that aims to remove all HTML comment start and end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\nGiven the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne possible fix for this issue is to apply the regular expression replacement repeatedly until no more replacements can be performed. This ensures that the unsafe text does not re-appear in the sanitized input, effectively removing all instances of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input) {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g, \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\n## Example\nAnother example is the following regular expression intended to remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"&lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\nA fix for this issue is to rewrite the regular expression to match single characters (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the sanitization process and ensures that all potentially unsafe characters are removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the popular `sanitize-html` npm library. It keeps most of the safe HTML tags while removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\.\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences of `/../` from `str`. This will not work as expected: for the string `/./.././`, for example, it will remove the single occurrence of `/../` in the middle, but the remainder of the string then becomes `/../`, which is another instance of the substring we were trying to remove.\n\nA possible fix for this issue is to use the \"sanitize-filename\" npm library for path sanitization. This library is specifically designed to handle path sanitization, and should handle all corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "security_severity_level": "high"
      },
      "tool": {
        "name": "CodeQL",
        "guid": null,
        "version": "2.18.1"
      },
      "most_recent_instance": {
        "ref": "refs/heads/3.3.001",
        "analysis_key": ".github/workflows/codeql.yml:analyze",
        "environment": "{\"build-mode\":\"none\",\"language\":\"javascript-typescript\"}",
        "category": "/language:javascript-typescript",
        "state": "open",
        "commit_sha": "5937b7a28f966150318c7346438c37ff19552a81",
        "message": {
          "text": "This string may still contain <script, which may cause an HTML element injection vulnerability."
        },
        "location": {
          "path": "vehicle/OVMS.V3/components/ovms_webserver/assets/tables.js",
          "start_line": 77,
          "end_line": 77,
          "start_column": 213,
          "end_column": 229
        },
        "classifications": []
      },
      "instances_url": "https://api.github.com/repos/Be-Secure/Open-Vehicle-Monitoring-System-3/code-scanning/alerts/1/instances"
    }
  ]
  
  